// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>

import { Ast, } from 'thingtalk';

// import the combinator library
import * as C from './ast_manip';
import _tpLoader from './load-thingpedia';

import { SlotBag } from './slot_bag';

import './common-constants.genie';

// Thingpedia Grammar Rules

// the following are a all autogenerated by load-thingpedia.js

thingpedia_query : Ast.Table = {}
thingpedia_get_command : Ast.Table = {}
thingpedia_stream : Ast.Stream = {}
thingpedia_action : Ast.InvocationAction = {}
thingpedia_program : (Ast.Program & { schema : Ast.ExpressionSignature; }) = {}
thingpedia_who_question : Ast.Table = {}

thingpedia_search_question : Ast.VarRefValue = {}
thingpedia_slot_fill_question : string = {}
thingpedia_user_question : Array<[string, Type]> = {}

thingpedia_result : SlotBag = {}
thingpedia_action_past : Ast.InvocationAction = {}
thingpedia_error_message : ({ code : string, bag : SlotBag }) = {}

coref_constant : Ast.Value = {}

out_param_Numeric : Ast.VarRefValue = {
    out_param_Number;
    out_param_Currency;
    out_param_Measure_ms;
    out_param_Measure_byte;
    out_param_Measure_kg;
    out_param_Measure_C;
    out_param_Measure_m;
    out_param_Measure_m2;
    out_param_Measure_m3;
    out_param_Measure_mps;
}

out_param_Any : Ast.VarRefValue = {}
out_param_Array__Any : Ast.VarRefValue = {}
out_param_ArrayCount : Ast.VarRefValue = {}
out_param_npp = {}
out_param_npi = {}
out_param_avp = {}
out_param_pvp = {}
out_param_npv = {}
out_param_apv = {}
out_param_String   : Ast.VarRefValue = {}
out_param_Number   : Ast.VarRefValue = {}
out_param_Currency : Ast.VarRefValue = {}
out_param_Time     : Ast.VarRefValue = {}
out_param_Date     : Ast.VarRefValue = {}
out_param_Location : Ast.VarRefValue = {}
out_param_Measure_ms   : Ast.VarRefValue = {}
out_param_Measure_byte : Ast.VarRefValue = {}
out_param_Measure_kg   : Ast.VarRefValue = {}
out_param_Measure_C    : Ast.VarRefValue = {}
out_param_Measure_m    : Ast.VarRefValue = {}
out_param_Measure_m2   : Ast.VarRefValue = {}
out_param_Measure_m3   : Ast.VarRefValue = {}
out_param_Measure_mps  : Ast.VarRefValue = {}
out_param_RecurrentTimeSpecification : Ast.VarRefValue = {}

out_param_Array__Numeric : Ast.VarRefValue = {
    out_param_Array__Number;
    out_param_Array__Currency;
    out_param_Array__Measure_ms;
    out_param_Array__Measure_byte;
    out_param_Array__Measure_kg;
    out_param_Array__Measure_C;
    out_param_Array__Measure_m;
    out_param_Array__Measure_m2;
    out_param_Array__Measure_m3;
    out_param_Array__Measure_mps;
}

out_param_Array__String   : Ast.VarRefValue = {}
out_param_Array__Number   : Ast.VarRefValue = {}
out_param_Array__Currency : Ast.VarRefValue = {}
out_param_Array__Time     : Ast.VarRefValue = {}
out_param_Array__Date     : Ast.VarRefValue = {}
out_param_Array__Location : Ast.VarRefValue = {}
out_param_Array__Measure_ms   : Ast.VarRefValue = {}
out_param_Array__Measure_byte : Ast.VarRefValue = {}
out_param_Array__Measure_kg   : Ast.VarRefValue = {}
out_param_Array__Measure_C    : Ast.VarRefValue = {}
out_param_Array__Measure_m    : Ast.VarRefValue = {}
out_param_Array__Measure_m2   : Ast.VarRefValue = {}
out_param_Array__Measure_m3   : Ast.VarRefValue = {}
out_param_Array__Measure_mps   : Ast.VarRefValue= {}
out_param_Array__Compound : Ast.VarRefValue = {}  // used for aggregate filter only

input_param : string = {}

// helper prefix for "and" filters
// English overrides this to add "both" as well
both_prefix : string = {
    '';
}

// filters & input parameters on npp parameters
// nnp: Noun-Phrase parameter for Property of the subject
// e.g.: "name", "date of birth"

npp_filter : Ast.BooleanExpression = {}
npp_input_param : Ast.InputParam = {}
npp_argminmax : [Ast.VarRefValue, 'asc'|'desc'] = {}
coref_npp_filter : Ast.BooleanExpression = {}
coref_npp_input_param : Ast.InputParam = {}
npp_boolean_projection = {}

// filters & input parameters on npi parameters
// npi: Noun-phrase parameter for Identity of the subejct
// e.g.: "owner of <company>", "student in <university>"
npi_filter : Ast.BooleanExpression = {}
npi_input_param : Ast.InputParam = {}
npi_argminmax : [Ast.VarRefValue, 'asc'|'desc'] = {}
coref_npi_filter : Ast.BooleanExpression = {}
coref_npi_input_param : Ast.InputParam = {}
npi_boolean_projection = {}

// filters & input parameters on pvp parameters
// pvp: Passive-Verb Phrase parameter
// e.g.: "called <nickname>", "born on <date>"
pvp_filter : Ast.BooleanExpression = {}
pvp_input_param : Ast.InputParam = {}
pvp_argminmax : [Ast.VarRefValue, 'asc'|'desc'] = {}
coref_pvp_filter : Ast.BooleanExpression = {}
coref_pvp_input_param : Ast.InputParam = {}
pvp_boolean_projection = {}

// filters & input parameters on prep parameters
// prep: preposition parameter
// e.g.: "at <time>", "in <area>"
preposition_filter : Ast.BooleanExpression = {}
preposition_input_param : Ast.InputParam = {}
preposition_argminmax : [Ast.VarRefValue, 'asc'|'desc'] = {}
coref_preposition_filter : Ast.BooleanExpression = {}
coref_preposition_input_param : Ast.InputParam = {}
preposition_boolean_projection = {}

// filters & input parameters on avp parameters
// avp: Active-Verb Phrase parameter
// e.g.: "owns <company>", "studied in <university>"
avp_filter : Ast.BooleanExpression = {}
avp_input_param : Ast.InputParam = {}
avp_argminmax : [Ast.VarRefValue, 'asc'|'desc'] = {}
coref_avp_filter : Ast.BooleanExpression = {}
coref_avp_input_param : Ast.InputParam = {}
avp_boolean_projection = {}

// filters & input parameters on npv parameters
// npv: implicit parameter with Noun-Phrase Value, i.e., the parameter itself will not appear in the sentence
// e.g.: "Bob is a PhD", the parameter `academic_degree` is implicit, and should be inferred by the value "PhD"
npv_filter : Ast.BooleanExpression = {}
npv_input_param : Ast.InputParam = {}
npv_argminmax : [Ast.VarRefValue, 'asc'|'desc'] = {}
coref_npv_filter : Ast.BooleanExpression = {}
coref_npv_input_param : Ast.InputParam = {}
npv_boolean_projection = {}

// filters & input parameters on apv parameter
// apv: implicit parameter with Adjective-Phrase Value (similar to npv, but in adjective form)
// e.g.: "Bob is left-handed"
apv_filter : Ast.BooleanExpression = {}
apv_input_param : Ast.InputParam = {}
apv_argminmax : [Ast.VarRefValue, 'asc'|'desc'] = {}
coref_apv_filter : Ast.BooleanExpression = {}
coref_apv_input_param : Ast.InputParam = {}
apv_boolean_projection = {}

// filters & input parameters on reverese_verb parameter
// reverese verb: verb-phrase parameter where value is the subject of the verb phrase
// e.g., "moveis that Bob directed"
reverse_verb_filter : Ast.BooleanExpression = {}
apv_input_param : Ast.InputParam = {}
coref_reverse_verb_filter : Ast.BooleanExpression = {}
coref_reverse_verb_input_param : Ast.InputParam = {}

// projections
question_projection_table = {}
command_projection_table = {}


constant_name : Ast.EntityValue = {}

base_table : Ast.InvocationTable = {}
base_noun_phrase : string = {}
generic_anything_noun_phrase : Ast.InvocationTable = {}
generic_base_noun_phrase : Ast.InvocationTable = {}

{
await _tpLoader.init($runtime, $grammar, $locale, $options);
}

// empty defaults for certain parameter types in case we don't have devices with
// those parameters
projection_Entity__tt__username : Ast.Table = {}
projection_Entity__tt__email_address : Ast.Table = {}

for (let [pname, [typestr,]] of _tpLoader.params.in.values()) {
    thingpedia_stream : Ast.Stream = {
        s:thingpedia_stream v:$('constant_' + typestr) [-> pname { isConstant: true }] => C.replacePlaceholderWithConstant(s, pname, v);
    }

    thingpedia_query : Ast.Table = {
        q:thingpedia_query v:$('constant_' + typestr) [-> pname { isConstant: true }] => C.replacePlaceholderWithConstant(q, pname, v);
    }

    thingpedia_get_command : Ast.Table = {
        q:thingpedia_get_command v:$('constant_' + typestr) [-> pname { isConstant: true }] => C.replacePlaceholderWithConstant(q, pname, v);
    }

    thingpedia_action : Ast.InvocationAction = {
        a:thingpedia_action v:$('constant_' + typestr) [-> pname { isConstant: true }] => C.replacePlaceholderWithConstant(a, pname, v);
    }

    thingpedia_action_past : Ast.InvocationAction = {
        a:thingpedia_action_past v:$('constant_' + typestr) [-> pname { isConstant: true }] [priority=0.5] => C.replacePlaceholderWithConstant(a, pname, v);
    }

    thingpedia_error_message : ({ code : string, bag : SlotBag }) = {
        msg:thingpedia_error_message v:$('constant_' + typestr) [-> pname { isConstant: true }] [priority=0.5] => C.replaceErrorMessagePlaceholder(msg, pname, v);
    }

    thingpedia_program : (Ast.Program & { schema : Ast.ExpressionSignature; }) = {
        p:thingpedia_program v:$('constant_' + typestr) [-> pname { isConstant: true }] => C.replacePlaceholderWithConstant(p, pname, v);
    }

    // don't parameter pass booleans or enums, as that rarely makes sense
    if (typestr !== 'Boolean' && !typestr.startsWith('Enum__')) {
        if (pname !== 'count' && pname !== 'p_count') {
            if ($options.flags.undefined_filter) {
                // replace $-placeholders with "some X" where X is based on parameter type
                thingpedia_query : Ast.Table = q:thingpedia_query $('placeholder_' + typestr) [-> pname { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(q, pname, typestr);

                thingpedia_get_command : Ast.Table = q:thingpedia_get_command $('placeholder_' + typestr) [-> pname { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(q, pname, typestr);

                thingpedia_stream : Ast.Stream = s:thingpedia_stream $('placeholder_' + typestr) [-> pname { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(s, pname, typestr);

                thingpedia_action : Ast.InvocationAction = a:thingpedia_action $('placeholder_' + typestr) [-> pname { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(a, pname, typestr);

                thingpedia_program : (Ast.Program & { schema : Ast.ExpressionSignature; }) = p:thingpedia_program $('placeholder_' + typestr) [-> pname { isUndefined: true }] =>
                    C.replacePlaceholderWithUndefined(p, pname, typestr);
            }
        }
    }
}

for (let [pname, typestr] of _tpLoader.params.out.values()) {
    if (typestr !== null) {
        thingpedia_result : SlotBag = {
            bag:thingpedia_result v:$('constant_name') [-> pname { isConstant: true }] [priority=0.1] => C.replaceSlotBagPlaceholder(bag, pname, v);
            bag:thingpedia_result v:$('constant_' + typestr) [-> pname { isConstant: true }] [priority=0.1] => C.replaceSlotBagPlaceholder(bag, pname, v);
        }
    }
}
