// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2019 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details

// contextual templates for Genie

{
const assert = require('assert');

const ThingTalk = require('thingtalk');
const Ast = ThingTalk.Ast;
const Type = ThingTalk.Type;

// import the combinator library
const C = require('../ast_manip');

function addParamToAction(command, pname, joinArg) {
    let actiontype = command.action.schema.inReq[pname];
    if (!actiontype)
        return null;
    let commandtype = joinArg.isEvent ? Type.String : command.table.schema.out[joinArg.name];
    if (!commandtype || !commandtype.equals(actiontype))
        return null;

    let reduced = C.betaReduce(command.action, pname, joinArg);
    if (reduced === null)
        return null;
    return { table: command.table, action: reduced };
}

function addParamToQuery(command, pname, joinArg) {
    let rhstype = command.rhs.schema.inReq[pname];
    if (!rhstype)
        return null;
    let lhstype = joinArg.isEvent ? Type.String : command.lhs.schema.out[joinArg.name];
    if (!lhstype || !lhstype.equals(rhstype))
        return null;

    let [passign, etaReduced] = C.etaReduceTable(command.rhs, pname);
    if (passign === undefined) {
        //console.error(`Ignored join between ${into} and ${projection}: cannot find parameter ${pname}`);
        return null;
    }
    //assert(etaReduced);
    //console.log('passign: ' + passign + ', ptype: ' + ptype);

    return {
        lhs: command.lhs,
        rhs: etaReduced,
        args: command.args.concat([new Ast.InputParam(passign, joinArg)])
    };
}

}

import './constants';
import './timers';
import './filters';
import './parameters';
import './stream_tables';

context complete_query_program = C.isQueryProgram($) && C.isCompleteCommand($);
context immediate_program = $.isProgram && !C.isContinuousProgram($);
context incomplete_program = !C.isCompleteCommand($);
context when_program = $.isProgram && $.rules.some((r) => r.isRule);
context policy = $.isPermissionRule;

chain_action = {
    q:complete_query_program action:thingpedia_action if !complete => {
        // make up a structure containing both the output parameters
        assert(q.rules.length === 1 && q.rules[0].table);

        const table = q.rules[0].table;
        return {
            table,
            action
        };
    };
}
chain_query = {
    (
          q:complete_query_program rhs:thingpedia_get_command
        | q:complete_query_program 'recupera' rhs:thingpedia_query
        | q:complete_query_program ('dimmi' | 'dammi' | 'mostrami' | 'presenta' | 'recupera') rhs:thingpedia_query
        | q:complete_query_program ('cerca' | 'trova' | 'voglio' | 'ho bisogno di') rhs:thingpedia_query
        | q:complete_query_program 'cosa sono' rhs:thingpedia_query '?'
    ) if !complete => {
        // make up a structure containing both the output parameters
        assert(q.rules.length === 1 && q.rules[0].table);

        const lhs = q.rules[0].table;
        return {
            lhs, rhs,
            args: []
        };
    };
}

for (let [pname, [typestr, pcanonical]] of $options.params.in.values()) {
    // don't parameter pass booleans or enums, as that rarely makes sense
    if (typestr !== 'Boolean' && !typestr.startsWith('Enum__')) {
        if ($options.types.id.has(typestr)) {
            chain_action = command:chain_action ('-lo' | '-la' | '-le' | '-li' | 'quello' | 'quella' | 'quelle' | 'quegli') [-> pname] => {
                for (let joinArg in command.table.schema.out) {
                    if (typestr === C.typeToStringSafe(command.table.schema.out[joinArg]))
                        return addParamToAction(command, pname, new Ast.Value.VarRef(joinArg));
                }
                return null;
            };

            chain_query = command:chain_query ('-lo' | '-la' | '-le' | '-li' | 'quello' | 'quella' | 'quelle' | 'quegli') [-> pname] => {
                for (let joinArg in command.lhs.schema.out) {
                    if (typestr === C.typeToStringSafe(command.lhs.schema.out[joinArg]))
                        return addParamToQuery(command, pname, new Ast.Value.VarRef(joinArg));
                }
                return null;
            };
        } else {
            chain_action = command:chain_action p:$('the_out_param_' + typestr) [-> pname] => addParamToAction(command, pname, p);
            chain_query = command:chain_query p:$('the_out_param_' + typestr) [-> pname] => addParamToQuery(command, pname, p);
        }

        if (pname === 'p_picture_url') {
            chain_action = command:chain_action ('-lo' | '-la' | '-le' | '-li' | 'quello' | 'quella' | 'quelle' | 'quegli') [-> pname] => addParamToAction(command, pname, new Ast.Value.VarRef('picture_url'));
            chain_query = command:chain_query ('-lo' | '-la' | '-le' | '-li' | 'quello' | 'quella' | 'quelle' | 'quegli') [-> pname] => addParamToQuery(command, pname, new Ast.Value.VarRef('picture_url'));
        }

        if (typestr === 'String' && ['p_body', 'p_message', 'p_caption', 'p_status', 'p_text'].indexOf(pname) >= 0) {
            chain_action = command:chain_action ('-lo' | '-la' | '-le' | '-li' | 'quello' | 'quella' | 'quelle' | 'quegli') [-> pname] => {
                for (let pname in command.table.schema.out) {
                    if (pname === 'picture_url')
                        return null;
                    let ptype = command.table.schema.out[pname];
                    if ($options.types.id.has(C.typeToStringSafe(ptype)))
                        return null;
                }
                return addParamToAction(command, pname, new Ast.Value.Event(null));
            };
            chain_query = command:chain_query ('-lo' | '-la' | '-le' | '-li' | 'quello' | 'quella' | 'quelle' | 'quegli') [-> pname] => {
                for (let pname in command.lhs.schema.out) {
                    if (pname === 'picture_url')
                        return null;
                    let ptype = command.lhs.schema.out[pname];
                    if ($options.types.id.has(C.typeToStringSafe(ptype)))
                        return null;
                }
                return addParamToQuery(command, pname, new Ast.Value.Event(null));
            };
        }
    }
}

$root = {
    command:chain_action if complete => {
        let { table, action } = command;

        // if the table is monitorable, run it again
        if (table.schema.is_monitorable) {
            return C.makeProgram(new Ast.Statement.Command(table, [action]))
        } else {
            // otherwise, make a result() expression referring to the last type involved

            const functionNames = C.findFunctionNameTable(table);
            const [kind, fname] = functionNames[functionNames.length-1].split(':');
            table = new Ast.Table.ResultRef(kind, fname, new Ast.Value.Number(-1), table.schema);
            return C.makeProgram(new Ast.Statement.Command(table, [action]));
        }
    };
    command:chain_query if complete => {
        let { lhs, rhs, args } = command;

        // if the previous command is monitorable, run it again
        if (lhs.schema.is_monitorable) {
            return C.makeProgram(new Ast.Statement.Command(
                new Ast.Table.Join(lhs, rhs, args, rhs.schema), [
                C.notifyAction()]))
        } else {
            // otherwise, make a result() expression referring to the last type involved

            const functionNames = C.findFunctionNameTable(lhs);
            const [kind, fname] = functionNames[functionNames.length-1].split(':');
            const ref = new Ast.Table.ResultRef(kind, fname, new Ast.Value.Number(-1), lhs.schema);
            return C.makeProgram(new Ast.Statement.Command(
                new Ast.Table.Join(ref, rhs, args, rhs.schema), [C.notifyAction()]));
        }
    };

     ( q:complete_query_program 'mostrami' p:constant_Any 'invece'
    ) => C.replaceAnyParameterFromContext(q, p);

    p:complete_query_program ('fallo di nuovo' | 'di nuovo' | 'un altro' | 'un\' altra' | 'eseguilo di nuovo' | 'esegui di nuovo') => {
        if (p.rules[0].table.schema.is_monitorable)
            return null;
        return p;
    };

    prog:immediate_program ('fai questo' | 'fallo' | 'ripeti questo comando' | 'imposta che questo si esegua') t:timer => C.addTimerToProgram(prog, t);
    prog:complete_query_program ('mandamelo' | 'mandami questo' | 'voglio vederlo' | 'lo voglio' | 'voglio questo' | 'manda questo') t:timer => C.addTimerToProgram(prog, t);
    
    prog:immediate_program ('fai questo' | 'fallo' | 'fallo automaticamente') stream:stream => C.addTimerToProgram(prog, stream);
    prog:complete_query_program ('mandamelo' | 'mandami questo' | 'voglio vederlo' | 'lo voglio' | 'voglio questo' | 'manda questo') stream:stream => C.addTimerToProgram(prog, stream);

    prog:complete_query_program ('ok , notificami quando cambia' | 'notificami quando cambia' | 'fammi sapere se ci sono cambiamenti' | 'fammi sapere se qualcosa cambia' | 'notificami di questo' | 'abbonati a questo') => {
        if (prog.rules.length > 1 || !prog.rules[0].table || !prog.rules[0].table.schema.is_monitorable)
            return null;
        return C.makeMonitor(prog);
    };

    !turking prog:incomplete_program ('' | 'la risposta Ã¨' | 'usa' | 'voglio') param:constant_Any => C.fillNextSlot(prog, param);

    q:complete_query_program ('solo quelli con' | 'solo quelli che hanno' |
        'solo con' | 'solo se hanno' | 'filtra quelli con' | 'mostrami solo quelli con') filter:with_filter => {
        if (!q.rules[0].table.schema.is_list)
            return null;
        return C.addFilterToProgram(q, filter, $options);
    };
    !turking q:complete_query_program ('mostrami se' | 'solo se') filter:atom_filter => {
        if (!q.rules[0].table.schema.is_list)
            return null;
        return C.addFilterToProgram(q, filter, $options);
    };

    prog:when_program ('solo se' | 'fallo solo se' | 'e solo quando' | 'solo quando') filter:atom_filter => C.addFilterToProgram(prog, filter, $options);
    prog:when_program ('solo se' | 'fallo solo se' | 'e solo quando' | 'solo quando') filter:get_predicate_filter => C.addFilterToProgram(prog, filter, $options);

    prog:when_program ('solo quelli con' | 'solo quelli che hanno' |
        'solo con' | 'solo se hanno' | 'filtra quelli con' | 'mostrami solo quelli con') filter:with_filter => {
        if (!prog.rules[0].stream.schema.is_list)
            return null;
        return C.addFilterToProgram(prog, filter, $options);
    };

    prog:policy ('solo se' | 'fallo solo se' | 'e solo quando' | 'solo quando') filter:atom_filter => C.addFilterToPolicy(prog, filter, $options);
    prog:policy ('solo se' | 'fallo solo se' | 'e solo quando' | 'solo quando') filter:get_predicate_filter => C.addFilterToPolicy(prog, filter, $options);
}
