// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2017-2018 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details

{
const assert = require('assert');

const ThingTalk = require('thingtalk');
const Ast = ThingTalk.Ast;
const Type = ThingTalk.Type;

// import the combinator library
const C = require('../ast_manip');
}

// generic filters (npp)
get_predicate_filter = {
    'prima di' t1:constant_Time => C.timeGetPredicate($options, null, t1);
    'dopo' t2:constant_Time  => C.timeGetPredicate($options, t2, null);
    ('tra' | 'fra') t1:constant_Time 'e' t2:constant_Time => C.timeGetPredicate($options, t1, t2);

    'la mia posizione è' loc:constant_Location     => C.locationGetPredicate($options, loc);
    'la mia posizione non è' loc:constant_Location => C.locationGetPredicate($options, loc, true);
    'sono a' loc:constant_Location            => C.locationGetPredicate($options, loc);
    'non sono a' loc:constant_Location        => C.locationGetPredicate($options, loc, true);
    
    ( proj:projection_Any_masculine ('è' | 'è esattamente' | 'è uguale a') x:constant_Any
    | proj:projection_Any_feminine ('è' | 'è esattamente' | 'è uguale a') x:constant_Any
    ) => C.makeGetPredicate(proj, '==', x);
    ( proj:projection_Any ('non è' | 'è diverso da') x:constant_Any
    | proj:projection_Any ('non è' | 'è diversa da') x:constant_Any
    ) => C.makeGetPredicate(proj, '==', x, true);
}

atom_filter = {
    ( 'il' p:out_param_Any_masculine ('è' | 'è esattamente' | 'è uguale a') x:constant_Any
    | 'la' p:out_param_Any_feminine ('è' | 'è esattamente' | 'è uguale a') x:constant_Any ) => {
        if (x.getType().isString)
            return C.makeFilter($options, p, '=~', x);
        else
            return C.makeFilter($options, p, '==', x);
    };
    ( 'il' p:out_param_Any_masculine ('non è' | 'è diverso da') x:constant_Any |
    | 'la' p:out_param_Any_feminine ('non è' | 'è diversa da') x:constant_Any ) => {
        if (x.getType().isString)
            return C.makeFilter($options, p, '=~', x, true);
        else
            return C.makeFilter($options, p, '==', x, true);
    };

    //p:the_out_param_Numeric 'è' ('greater' | 'higher' | 'bigger' | 'more' | 'at least' | 'not less than') x:constant_Numeric => C.makeFilter($options, p, '>=', x);
    //p:the_out_param_Numeric 'è' ('smaller' | 'lower' | 'less' | 'at most' | 'not more than') x:constant_Numeric             => C.makeFilter($options, p, '<=', x);
    
    // >=
    ( 'il' p:out_param_Number_masculine 'è' ('più grande di' | 'superiore a' | 'più alto di' | 'più di' | 'almeno' | 'non meno di') x:constant_Number
    | 'la' p:out_param_Number_feminine 'è' ('più grande di' | 'superiore a' | 'più alta di' | 'più di' | 'almeno' | 'non meno di') x:constant_Number

    | 'il' p:out_param_Currency_masculine 'è' ('più caro' | 'più costoso' | 'più') 'di' x:constant_Currency
    | 'la' p:out_param_Currency_feminine 'è' ('più cara' | 'più costosa' | 'più') 'di' x:constant_Currency

    | 'il' p:out_param_Measure_ms_masculine 'è più lungo di' x:constant_Measure_ms
    | 'la' p:out_param_Measure_ms_feminine 'è più lunga di' x:constant_Measure_ms

    | 'il' p:out_param_Measure_byte_masculine 'è' ('più grande' | 'più') 'di' x:constant_Measure_byte
    | 'la' p:out_param_Measure_byte_feminine 'è' ('più grande' | 'più') 'di' x:constant_Measure_byte

    | 'il' p:out_param_Measure_kg_masculine 'è' ('più pesante' | 'più grande' | 'più') 'di' x:constant_Measure_kg
    | 'la' p:out_param_Measure_kg_feminine 'è' ('più pesante' | 'più grande' | 'più') 'di' x:constant_Measure_kg

    | 'il' p:out_param_Measure_C_masculine 'è' ('più caldo' | 'più alto') 'di' x:constant_Measure_C
    | 'la' p:out_param_Measure_C_feminine 'è' ('più calda' | 'più alta') 'di' x:constant_Measure_C

    | 'il' p:out_param_Measure_m_masculine 'è' ('più distante' | 'più lontano' | 'più lungo') 'di' x:constant_Measure_m
    | 'la' p:out_param_Measure_m_feminine 'è' ('più distante' | 'più lontana' | 'più lunga') 'di' x:constant_Measure_m

    | 'il' p:out_param_Measure_mps_masculine 'è più veloce di' x:constant_Measure_mps
    | 'il' p:out_param_Measure_mps_feminine 'è più veloce di' x:constant_Measure_mps

    ) => C.makeFilter($options, p, '>=', x);

    // <=
    ( 'il' p:out_param_Number_masculine 'è' ('più piccolo di' | 'inferiore a' | 'meno di' | 'al più' | 'non più di') x:constant_Number
    | 'la' p:out_param_Number_feminine 'è' ('più piccola di' | 'inferiore a' | 'meno di' | 'al più' | 'non più di') x:constant_Number

    | 'il' p:out_param_Currency_masculine 'è' ('meno caro' | 'meno costoso' | 'meno') 'di' x:constant_Currency
    | 'la' p:out_param_Currency_feminine 'è' ('meno cara' | 'meno costosa' | 'meno') 'di' x:constant_Currency

    | 'il' p:out_param_Measure_ms_masculine 'è più' ('corto' | 'breve') 'di' x:constant_Measure_ms
    | 'la' p:out_param_Measure_ms_feminine 'è più' ('corta' | 'breve') 'di' x:constant_Measure_ms

    | 'il' p:out_param_Measure_byte_masculine 'è' ('più piccolo' | 'meno') 'di' x:constant_Measure_byte
    | 'la' p:out_param_Measure_byte_feminine 'è' ('più piccola' | 'meno') 'di' x:constant_Measure_byte

    | 'il' p:out_param_Measure_kg_masculine 'è' ('più leggero' | 'più piccolo') 'di' x:constant_Measure_kg
    | 'la' p:out_param_Measure_kg_feminine 'è' ('più leggera' | 'più piccola') 'di' x:constant_Measure_kg

    | 'il' p:out_param_Measure_C_masculine 'è' ('più freddo' | 'meno') 'di' x:constant_Measure_C
    | 'la' p:out_param_Measure_C_feminine 'è' ('più fredda' | 'meno') 'di' x:constant_Measure_C

    | 'il' p:out_param_Measure_m_masculine 'è' ('più vicino' | 'più corto' | 'più breve') 'di' x:constant_Measure_m
    | 'la' p:out_param_Measure_m_feminine 'è' ('più vicina' | 'più corta' | 'più breve') 'di' x:constant_Measure_m

    | 'il' p:out_param_Measure_mps_masculine 'è' ('più lento' | 'meno') 'di' x:constant_Measure_mps
    | 'la' p:out_param_Measure_mps_feminine 'è' ('più lenta' | 'meno') 'di' x:constant_Measure_mps

    ) => C.makeFilter($options, p, '<=', x);


    !turking {
        ( 'il' p:out_param_Date_masculine 'è' ('dopo' | 'più tardi di') x:constant_Date
        | 'la' p:out_param_Date_feminine 'è' ('dopo' | 'più tardi di') x:constant_Date

        | 'il' p:out_param_Time_masculine 'è' ('after' | 'later than') x:constant_Time
        | 'la' p:out_param_Time_feminine 'è' ('dopo' | 'più tardi di') x:constant_Time
        ) => C.makeFilter($options, p, '>=', x);

        ( 'il' p:out_param_Date_masculine 'è' 'prima di' x:constant_Date
        | 'la' p:out_param_Date_feminine 'è' 'prima di' x:constant_Date

        | 'il' p:out_param_Time_masculine 'è' 'prima di' x:constant_Time
        | 'la' p:out_param_Time_feminine 'è' 'prima di' x:constant_Time
        ) => C.makeFilter($options, p, '<=', x);
    }

    ( 'i' p:the_out_param_Array__Any_masculine 'contengono' x:constant_Any
    | 'le' p:the_out_param_Array__Any_feminine 'contengono' x:constant_Any
    ) => C.makeFilter($options, p, 'contains', x);
    ( 'i' p:the_out_param_Array__Any_masculine 'non contengono' x:constant_Any
    | 'le' p:the_out_param_Array__Any_feminine 'non contengono' x:constant_Any
    ) => C.makeFilter($options, p, 'contains', x, true);

    ( 'il' p:the_out_param_String_masculine ('contiene' | 'include') x:constant_String
    | 'la' p:the_out_param_String_feminine ('contiene' | 'include') x:constant_String
    ) => C.makeFilter($options, p, '=~', x);
    ( 'il' p:the_out_param_String_masculine 'non' ('contiene' | 'include') x:constant_String
    | 'la' p:the_out_param_String_feminine 'non' ('contiene' | 'include') x:constant_String
    ) => C.makeFilter($options, p, '=~', x, true);

    // "in il" / "in la" will be postprocessed (this way, we can postprocess to "nell'" or "nello"
    // if necessary)
    ( x:constant_String 'è in il' p:the_out_param_String_masculine
    | x:constant_String 'è in la' p:the_out_param_String_feminine
    ) => C.makeFilter($options, p, '=~', x);

    !turking range_filter;
    //!turking f:either_filter => f;
}

edge_filter = {
    !turking
    ( 'il' p:out_param_Any_masculine ('diventa' | 'diventa uguale a') x:constant_Any
    | 'la' p:out_param_Any_feminine ('diventa' | 'diventa uguale a') x:constant_Any
    ) => {
        if (x.getType().isString)
            return C.makeFilter($options, p, '=~', x);
        else
            return C.makeFilter($options, p, '==', x);
    };

    ( p:the_out_param_Numeric_masculine ('ora è maggiore di' | 'diventa maggiore di' | 'diventa più grande di' | 'cresce sopra' | 'sale sopra' | 'oltrepassa') x:constant_Numeric
    | p:the_out_param_Numeric_feminine ('ora è maggiore di' | 'diventa maggiore di' | 'diventa più grande di' | 'cresce sopra' | 'sale sopra' | 'oltrepassa') x:constant_Numeric
     )=> C.makeFilter($options, p, '>=', x);

    ( p:the_out_param_Numeric_masculine ('ora è minore di' | 'diventa minore di' | 'diventa più piccolo di' | 'scende sotto' | 'cala sotto') x:constant_Numeric
    | p:the_out_param_Numeric_feminine ('ora è minore di' | 'diventa minore di' | 'diventa più piccola di' | 'scende sotto' | 'cala sotto') x:constant_Numeric
    ) => C.makeFilter($options, p, '<=', x);
}

either_filter = {
    ( 'il' param:out_param_Any_masculine ('è' | 'è uguale a' | 'è uno di') v1:constant_Any ('o' | 'oppure') v2:constant_Any
    | 'la' param:out_param_Any_feminine ('è' | 'è uguale a' | 'è uno di') v1:constant_Any ('o' | 'oppure') v2:constant_Any
    ) => {
        // param is a Value.VarRef
        //console.log('param: ' + param.name);
        if (!v1.getType().equals(v2.getType()))
            return null;
        if (v1.equals(v2)) // can happen with constants (now, 0, 1, etc.)
            return null;
        if (v1.isVarRef && v1.constNumber !== undefined && v2.isVarRef && v2.constNumber !== undefined &&
            v1.constNumber + 1 !== v2.constNumber) // optimization: avoid CONST_X CONST_Y with X + 1 != Y earlier (before the NN catches it)
            return null;
        let vtype = v1.getType();
        if (vtype.isBoolean) // "is equal to true or false" does not make sense
            return null;
        if (!$options.params.out.has(param.name + '+' + vtype))
            return null;
        return new Ast.BooleanExpression.Atom(param.name, 'in_array', Ast.Value.Array([v1, v2]));
    };

    // XXX: to support typing, we might want to normalize acute accents to grave accents
    // because the Italian keyboard has acute accents behind Shift, so nobody types the right accent...
    // (voice and mobile keyboard should do the right thing here)
    ( 'il' param:out_param_Any_masculine ('non è' | 'non è né') v1:constant_Any 'né' v2:constant_Any
    | 'la' param:out_param_Any_feminine ('non è' | 'non è né') v1:constant_Any 'né' v2:constant_Any
    ) => {
        // param is a Value.VarRef
        //console.log('param: ' + param.name);
        if (!v1.getType().equals(v2.getType()))
            return null;
        if (v1.equals(v2)) // can happen with constants (now, 0, 1, etc.)
            return null;
        if (v1.isVarRef && v1.constNumber !== undefined && v2.isVarRef && v2.constNumber !== undefined &&
            v1.constNumber + 1 !== v2.constNumber) // optimization: avoid CONST_X CONST_Y with X + 1 != Y earlier (before the NN catches it)
            return null;
        let vtype = v1.getType();
        if (vtype.isBoolean) // "is neither true nor false" does not make sense
            return null;
        if (!$options.params.out.has(param.name + '+' + vtype))
            return null;
        return new Ast.BooleanExpression.Not(new Ast.BooleanExpression.Atom(param.name, 'in_array', Ast.Value.Array([v1, v2])));
    };
}

range = {
    'tra' v1:constant_Numeric 'e' v2:constant_Numeric => {
        if (!v1.getType().equals(v2.getType()))
            return null;
        if (v1.equals(v2)) // can happen with constants (now, 0, 1, etc.)
            return null;
        if (v1.isVarRef && v1.constNumber !== undefined && v2.isVarRef && v2.constNumber !== undefined &&
            v1.constNumber + 1 !== v2.constNumber) // optimization: avoid CONST_X CONST_Y with X + 1 != Y earlier (before the NN catches it)
            return null;
        return [v1, v2];
    };
    'nell\' intervallo da' v1:constant_Numeric 'a' v2:constant_Numeric => {
        if (!v1.getType().equals(v2.getType()))
            return null;
        if (v1.equals(v2)) // can happen with constants (now, 0, 1, etc.)
            return null;
        if (v1.isVarRef && v1.constNumber !== undefined && v2.isVarRef && v2.constNumber !== undefined &&
            v1.constNumber + 1 !== v2.constNumber) // optimization: avoid CONST_X CONST_Y with X + 1 != Y earlier (before the NN catches it)
            return null;
        return [v1, v2];
    };
}
range_filter = {
    ( param:the_out_param_Numeric_masculine 'è' range:range
    | param:the_out_param_Numeric_feminine 'è' range:range
    ) => {
        const [v1, v2] = range;
        return new Ast.BooleanExpression.And([
            Ast.BooleanExpression.Atom(param.name, '>=', v1),
            Ast.BooleanExpression.Atom(param.name, '<=', v2)
        ]);
    };
}

with_filter = {
    ( p:out_param_Any_masculine 'uguale a' x:constant_Any
    | p:out_param_Any_feminine 'uguale a' x:constant_Any
    ) => {
        if (x.getType().isString)
            return C.makeFilter($options, p, '=~', x);
        else
            return C.makeFilter($options, p, '==', x);
    };
    !turking
    ( p:out_param_String_masculine ('contenente' | 'che contiene' | 'che include') x:constant_String
    | p:out_param_String_feminine ('contenente' | 'che contiene' | 'che include') x:constant_String
    ) => C.makeFilter($options, p, '=~', x);
    !turking
    ( x:constant_String ('in il' | 'in il suo') p:out_param_String_masculine
    | x:constant_String ('in la' | 'in la sua') p:out_param_String_feminine
    ) => C.makeFilter($options, p, '=~', x);

    // >=
    ( 'il' p:out_param_Number_masculine ('più grande di' | 'superiore a' | 'più alto di' | 'maggiore di') x:constant_Number
    | 'la' p:out_param_Number_feminine ('più grande di' | 'superiore a' | 'più alta di' | 'maggiore di') x:constant_Number

    | 'il' p:out_param_Currency_masculine ('più caro' | 'più costoso' | 'maggiore') 'di' x:constant_Currency
    | 'la' p:out_param_Currency_feminine ('più cara' | 'più costosa' | 'maggiore') 'di' x:constant_Currency

    | 'il' p:out_param_Measure_ms_masculine ('più lungo' | 'maggiore') 'di' x:constant_Measure_ms
    | 'la' p:out_param_Measure_ms_feminine ('più lunga' | 'maggiore') 'di' x:constant_Measure_ms

    | 'il' p:out_param_Measure_byte_masculine ('più grande' | 'maggiore') 'di' x:constant_Measure_byte
    | 'la' p:out_param_Measure_byte_feminine ('più grande' | 'maggiore') 'di' x:constant_Measure_byte

    | 'il' p:out_param_Measure_kg_masculine ('più pesante' | 'più grande' | 'maggiore') 'di' x:constant_Measure_kg
    | 'la' p:out_param_Measure_kg_feminine ('più pesante' | 'più grande' | 'maggiore') 'di' x:constant_Measure_kg

    | 'il' p:out_param_Measure_C_masculine ('più caldo' | 'più alto' | 'maggiore') 'di' x:constant_Measure_C
    | 'la' p:out_param_Measure_C_feminine ('più calda' | 'più alta' | 'maggiore') 'di' x:constant_Measure_C

    | 'il' p:out_param_Measure_m_masculine ('più distante' | 'più lontano' | 'più lungo' | 'maggiore') 'di' x:constant_Measure_m
    | 'la' p:out_param_Measure_m_feminine ('più distante' | 'più lontana' | 'più lunga' | 'maggiore') 'di' x:constant_Measure_m

    | 'il' p:out_param_Measure_mps_masculine ('più veloce' | 'maggiore') 'di' x:constant_Measure_mps
    | 'il' p:out_param_Measure_mps_feminine ('più veloce' | 'maggiore') 'di' x:constant_Measure_mps

    ) => C.makeFilter($options, p, '>=', x);

    // <=
    ( 'il' p:out_param_Number_masculine ('più piccolo di' | 'inferiore a' | 'minore di') x:constant_Number
    | 'la' p:out_param_Number_feminine ('più piccola di' | 'inferiore a' | 'minore di') x:constant_Number

    | 'il' p:out_param_Currency_masculine ('meno caro' | 'meno costoso' | 'minore') 'di' x:constant_Currency
    | 'la' p:out_param_Currency_feminine ('meno cara' | 'meno costosa' | 'minore') 'di' x:constant_Currency

    | 'il' p:out_param_Measure_ms_masculine ('più corto' | 'breve' | 'minore') 'di' x:constant_Measure_ms
    | 'la' p:out_param_Measure_ms_feminine 'più' ('corta' | 'breve' | 'minore') 'di' x:constant_Measure_ms

    | 'il' p:out_param_Measure_byte_masculine ('più piccolo' | 'minore') 'di' x:constant_Measure_byte
    | 'la' p:out_param_Measure_byte_feminine ('più piccola' | 'minore') 'di' x:constant_Measure_byte

    | 'il' p:out_param_Measure_kg_masculine ('più leggero' | 'più piccolo' | 'minore') 'di' x:constant_Measure_kg
    | 'la' p:out_param_Measure_kg_feminine ('più leggera' | 'più piccola' | 'minore') 'di' x:constant_Measure_kg

    | 'il' p:out_param_Measure_C_masculine ('più freddo' | 'minore') 'di' x:constant_Measure_C
    | 'la' p:out_param_Measure_C_feminine ('più fredda' | 'minore') 'di' x:constant_Measure_C

    | 'il' p:out_param_Measure_m_masculine ('più vicino' | 'più corto' | 'più breve' | 'minore') 'di' x:constant_Measure_m
    | 'la' p:out_param_Measure_m_feminine ('più vicina' | 'più corta' | 'più breve' | 'minore') 'di' x:constant_Measure_m

    | 'il' p:out_param_Measure_mps_masculine ('più lento' | 'minore') 'di' x:constant_Measure_mps
    | 'la' p:out_param_Measure_mps_feminine ('più lenta' | 'minore') 'di' x:constant_Measure_mps

    ) => C.makeFilter($options, p, '<=', x);

    // "maggior temperatura di ..." is too poetic/uncommon to be meaningful
    //('greater' | 'higher' | 'larger' | 'more') p:out_param_Number 'di' x:constant_Number => C.makeFilter($options, p, '>=', x);
    //('smaller' | 'lower' | 'less') p:out_param_Number 'di' x:constant_Number  => C.makeFilter($options, p, '<=', x);

    !turking {
        f:range_with_filter => f;

        ( 'nessun' param:out_param_Number_masculine
        | 'nessuna' param:out_param_Number_feminine
        | 'zero' param:out_param_Number_masculine
        | 'zero' param:out_param_Number_feminine
        ) => new Ast.BooleanExpression.Atom(param.name, '==', Ast.Value.Number(0));
    }
}
range_with_filter = {
    param:out_param_Numeric range:range => {
        const [v1, v2] = range;
        return new Ast.BooleanExpression.And([
            Ast.BooleanExpression.Atom(param.name, '>=', v1),
            Ast.BooleanExpression.Atom(param.name, '<=', v2)
        ]);
    };
}

// filters on npp parameters
// nnp: Noun-Phrase parameter for Property of the subject
// e.g.: "name", "date of birth"
npp_filter = {
    ( p:out_param_npp_masculine x:constant_Any
    | p:out_param_npp_feminine x:constant_Any
    ) => {
        const op = x.getType().isString ? '=~' : '==';
        return C.makeFilter($options, p, op, x);
    };

    ( p:out_param_npp_masculine x:constant_Any
    | p:out_param_npp_feminine x:constant_Any
    ) => {
        return C.makeFilter($options, p, 'contains', x);
    };
}

// filters on npi parameters
// npi: Noun-phrase parameter for Identity of the subejct
// e.g.: "owner of <company>", "student in <university>"
npi_filter_masculine = {
    p:out_param_npi_masculine x:constant_Any => {
        const op = x.getType().isString ? '=~' : '==';
        return C.makeFilter($options, p, op, x);
    };
    p:out_param_npi_masculine x:constant_Any => {
        return C.makeFilter($options, p, 'contains', x);
    };
}
npi_filter_feminine = {
    p:out_param_npi_feminine x:constant_Any => {
        const op = x.getType().isString ? '=~' : '==';
        return C.makeFilter($options, p, op, x);
    };
    p:out_param_npi_feminine x:constant_Any => {
        return C.makeFilter($options, p, 'contains', x);
    };
}

// filters on pvp parameters
// pvp: Passive-Verb Phrase parameter
// e.g.: "called <nickname>", "born on <date>"
pvp_filter_masculine = {
    p:out_param_pvp_masculine x:constant_Any => {
        const op = x.getType().isString ? '=~' : '==';
        return C.makeFilter($options, p, op, x);
    };
    p:out_param_pvp_masculine x:constant_Any => {
        return C.makeFilter($options, p, 'contains', x);
    };
}
pvp_filter_feminine = {
    p:out_param_pvp_feminine x:constant_Any => {
        const op = x.getType().isString ? '=~' : '==';
        return C.makeFilter($options, p, op, x);
    };
    p:out_param_pvp_feminine x:constant_Any => {
        return C.makeFilter($options, p, 'contains', x);
    };
}

// filters on avp parameters
// avp: Active-Verb Phrase parameter
// e.g.: "owns <company>", "studied in <university>"
avp_filter = {
    // avp is a verb so does not distinguish masculine/feminine,
    // but we have both forms to simplify the code in SentenceGenerator
    ( p:out_param_avp_masculine x:constant_Any
    | p:out_param_avp_feminine x:constant_Any
    )  => {
        const op = x.getType().isString ? '=~' : '==';
        return C.makeFilter($options, p, op, x);
    };
    ( p:out_param_avp_masculine x:constant_Any
    | p:out_param_avp_feminine x:constant_Any
    ) => {
        return C.makeFilter($options, p, 'contains', x);
    };
}


// NOTE: npv & apv are not gendered (because out_param_* is the empty string)
//
// enum constants might need to be gendered to generate the correct sentence
// "Bob è mancino" vs "Alice è mancina" ("Bob/Alice is left-handed")
// but that would require a lot of pain to carry gender across constant_Any so we don't do it
//
// string constants are even worse, because we replace them much later
// we'll just train randomly, and hope for the best

// filters on npv parameters
// npv: implicit parameter with Noun-Phrase Value, i.e., the parameter itself will not appear in the sentence
// e.g.: "Bob is a doctor", the parameter `academic_degree` (or `jobTitle`) is implicit, and should be inferred by the value "doctor"
npv_filter = {
    p:out_param_npv x:constant_Any => {
        const op = x.getType().isString ? '=~' : '==';
        return C.makeFilter($options, p, op, x);
    };
    p:out_param_npv x:constant_Any => {
        return C.makeFilter($options, p, 'contains', x);
    };
}

// filters on apv parameter
// apv: implicit parameter with Adjective-Phrase Value (similar to npv, but in adjective form)
// e.g.: "Bob is left-handed"
apv_filter = {
    p:out_param_apv x:constant_Any => {
        const op = x.getType().isString ? '=~' : '==';
        return C.makeFilter($options, p, op, x);
    };
    p:out_param_apv x:constant_Any => {
        return C.makeFilter($options, p, 'contains', x);
    };
}

// filters on npp parameter for "whose" question
// e.g.: "boogie è il soprannome di chi?" (="whose nickname is boogie?")
whose_npp_filter = {
    ( x:constant_Any 'è il' p:out_param_npp_masculine
    | x:constant_Any 'è la' p:out_param_npp_feminine
    ) => {
        const op = x.getType().isString ? '=~' : '==';
        return C.makeFilter($options, p, op, x);
    };
    ( x:constant_Any 'è il' p:out_param_npp_masculine
    | x:constant_Any 'è la' p:out_param_npp_feminine
    ) => {
        return C.makeFilter($options, p, 'contains', x);
    };
}

// generic filters on parameters in all 6 grammar categories for "who" questions
who_generic_filter_masculine = {
    ( 'ha' p:out_param_npp_masculine x:constant_Any
    | 'ha' p:out_param_npp_feminine x:constant_Any
    ) => {
        const op = x.getType().isString ? '=~' : '==';
        return C.makeFilter($options, p, op, x);
    };
    ( 'ha' p:out_param_npp_masculine x:constant_Any
    | 'ha' p:out_param_npp_feminine x:constant_Any
    ) => {
        return C.makeFilter($options, p, 'contains', x);
    };

    'è il' p:out_param_npi_masculine x:constant_Any => {
        const op = x.getType().isString ? '=~' : '==';
        return C.makeFilter($options, p, op, x);
    };
    'è il' p:out_param_npi_masculine x:constant_Any => {
        return C.makeFilter($options, p, 'contains', x);
    };

    p:out_param_avp x:constant_Any => {
        const op = x.getType().isString ? '=~' : '==';
        return C.makeFilter($options, p, op, x);
    };
    p:out_param_avp x:constant_Any => {
        return C.makeFilter($options, p, 'contains', x);
    };

    'è' p:out_param_pvp_masculine x:constant_Any => {
        const op = x.getType().isString ? '=~' : '==';
        return C.makeFilter($options, p, op, x);
    };
    'è' p:out_param_pvp_masculine x:constant_Any => {
        return C.makeFilter($options, p, 'contains', x);
    };

    'è un' p:out_param_npv x:constant_Any => {
        const op = x.getType().isString ? '=~' : '==';
        return C.makeFilter($options, p, op, x);
    };
    'è un' p:out_param_npv x:constant_Any => {
        return C.makeFilter($options, p, 'contains', x);
    };

    'è' p:out_param_apv x:constant_Any => {
        const op = x.getType().isString ? '=~' : '==';
        return C.makeFilter($options, p, op, x);
    };
    'è' p:out_param_apv x:constant_Any => {
        return C.makeFilter($options, p, 'contains', x);
    };
}
