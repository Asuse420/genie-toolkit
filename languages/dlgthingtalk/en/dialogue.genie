// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2017-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details

{
    const assert = require('assert');
    const ThingTalk = require('thingtalk');
    const Ast = ThingTalk.Ast;
    const Type = ThingTalk.Type;

    const C = require('../ast_manip');
    const D = require('../dialogue_utils');

    // import thingpedia info
    const _tpLoader = require('../load-thingpedia');
}

import '../common';
import './constants';
import './timers';
import './filters';
import './parameters';
import './aggregation';
import './computation';
import './who_questions';
import './stream_tables';
import './commands';

context ctx_init,
    ctx_greet,
    ctx_with_result,
    ctx_with_action,
    ctx_with_result_and_action,
    ctx_with_result_question,
    ctx_with_result_noquestion,
    ctx_without_projection,
    ctx_search_command,
    ctx_aggregation_question,
    ctx_distance_argminmax_question,
    ctx_argminmax_question,
    ctx_one_result_question,
    ctx_empty_direct_question,
    ctx_empty_search_command,
    ctx_large_search_command,
    ctx_single_result_search_command,
    ctx_complete_search_command,
    ctx_completed_action_success,
    ctx_completed_action_error,
    ctx_confirm_action,
    ctx_incomplete_action,
    ctx_learn_more;

context function (state) {
    if (state === null)
        return [['ctx_init'], D.INITIAL_CONTEXT_INFO];
    assert(state instanceof Ast.DialogueState, `expected a dialogue state Ast node`);
    if (state.policy !== D.POLICY_NAME)
        return null;
    const info = D.getContextInfo(state);

    switch (state.dialogueAct) {
    case 'greet':
        assert(state.history.length === 0, `expected empty history for greet`);
        return [['ctx_greet'], info];

    case 'execute': {
        const tags = [];

        if (info.nextInfo !== null) {
            // we have an action we want to execute, or a query that needs confirmation
            if (info.nextInfo.chainParameter === null || info.nextInfo.chainParameterFilled) {
                // we don't need to fill any parameter from the current query

                if (info.nextInfo.isComplete) {
                    return [['ctx_confirm_action'], info];
                } else {
                    return [['ctx_incomplete_action'], info];
                }
            }

            tags.push('ctx_with_action');
        }

        // we must have a result
        assert(info.resultInfo, `expected result info`);
        if (!info.resultInfo.isTable)
            return [['ctx_completed_action_success'], info];

        if (info.resultInfo.hasEmptyResult) {
            // note: aggregation cannot be empty (it would be zero)
            tags.push('ctx_empty_search_command');
            return [tags, info];
        }

        tags.push('ctx_with_result');
        if (D.isUserAskingResultQuestion(info)) {
            tags.push('ctx_with_result_question');
        } else {
            tags.push('ctx_with_result_noquestion');
            if (info.nextInfo)
                tags.push('ctx_with_result_and_action');

            if (info.resultInfo.projection === null)
                tags.push('ctx_without_projection');
        }

        if (info.resultInfo.isQuestion) {
            if (info.resultInfo.isAggregation) {
                // "how many restaurants nearby have more than 500 reviews?"
                tags.push('ctx_aggregation_question');
            } else if (info.resultInfo.argMinMaxField !== null) {
                const [field, direction] = info.resultInfo.argMinMaxField;

                /* FIXME
                // for now, we treat these as single result questions
                if (field === 'distance') // "find the nearest starbucks"
                    tags.push('ctx_distance_argminmax_question');
                else // "what is the highest rated restaurant nearby?"
                    tags.push('ctx_argminmax_question');
                */
                tags.push('ctx_single_result_search_command');
            } else if (info.resultInfo.hasSingleResult) {
                // "what is the rating of Terun?"
                // FIXME if we want to answer differently, we need to change this one
                tags.push('ctx_single_result_search_command');
            } else {
                // "what's the food and price range of restaurants nearby?"
                // we treat these the same as "find restaurants nearby", but we make sure
                // that the necessary fields are computed
                tags.push('ctx_search_command');

                // we can recommend/show the result right away, even if many match
                tags.push('ctx_complete_search_command');
            }
        } else {
            if (info.resultInfo.hasSingleResult || info.resultInfoQuestion) // we can recommend
                tags.push('ctx_single_result_search_command')
            else // we can refine
                tags.push('ctx_search_command');

            if (!info.resultInfo.hasLargeResult) // we can /show the result
                tags.push('ctx_complete_search_command');
        }

        return [tags, info];
    }

    case 'learn_more':
        assert(info.results);
        return [['ctx_learn_more'], info];

    default:
        throw new Error(`Unexpected user dialogue act ${info.dialogueAct}`);
    }
}

search_result_preamble = {
    ctx:ctx_search_command ('there are' | 'i can see' | 'i have found' | 'i can recommend') ('many' | 'several') base:base_noun_phrase
        ('matching your request' | 'matching your constraints' | 'with those characteristics' | 'like that' | '') '.'
        => D.checkSearchResultPreamble(ctx, base, null, false);

    ctx:ctx_search_command ('there are' | 'i have found' | 'i have' | 'i can see') num:constant_Number base:base_noun_phrase
        ('in my database' | 'like that') '.'
        => D.checkSearchResultPreamble(ctx, base, num, false);
}

direct_slot_fill_question = {
    ( 'what' p:out_param_Any 'do you want ?'
    | 'what' p:out_param_Any 'would you prefer ?'
    | 'what' p:out_param_Any 'would you like ?'
    | 'what' p:out_param_Any 'are you interested in ?'
    | 'what' p:out_param_Any 'are you looking for ?'
    ) => {
        if (p.name === 'id')
            return null;
        return p.name;
    };
}

yesno_direct_slot_fill_question = {
    ( 'any preference of' p:out_param_Any '?'
    | 'do you have a specific' p:out_param_Any 'in mind?'
    | 'do you have a preference of' p:out_param_Any '?'
    | 'do you have a preferred' p:out_param_Any '?'
    | 'are you looking for a specific' p:out_param_Any '?'
    ) => {
        if (p.name === 'id')
            return null;
        return p.name;
    };
}

generic_answer = {
    // TODO
}

imprecise_answer_phrase = {
    ( slot:constant_Any
    | slot:npp_filter
    | slot:apv_filter
    | slot:pvp_filter
    | slot:preposition_filter
    ) => slot;
}

imprecise_answer = {
    ans:imprecise_answer_phrase ('please' | '') '.' => ans;

    generic_preamble_for_answer ans:imprecise_answer_phrase '.' => ans;
}

verbose_answer = {
    // complete answer, like "I am looking for a bla restaurant"
    generic_preamble_for_answer ('a' | 'the') query:answer_noun_phrase => query;
}

question_npp_filter_pair = {
    ctx:ctx_with_result_noquestion f1:npp_filter 'or' f2:npp_filter =>
        D.checkFilterPairForDisjunctiveQuestion(ctx, f1, f2);
    ctx:ctx_with_result_noquestion f1:npp_filter 'or' c:constant_Any  =>
        D.checkFilterPairForDisjunctiveQuestion(ctx, f1, new Ast.BooleanExpression.Atom(null, f1.name, f1.operator, c));
}
question_apv_filter_pair = {
    ctx:ctx_with_result_noquestion f1:apv_filter 'or' f2:apv_filter =>
        D.checkFilterPairForDisjunctiveQuestion(ctx, f1, f2);
}
question_avp_filter_pair = {
    ctx:ctx_with_result_noquestion f1:avp_filter 'or' c:constant_Any =>
        D.checkFilterPairForDisjunctiveQuestion(ctx, f1, new Ast.BooleanExpression.Atom(null, f1.name, f1.operator, c));
}
question_preposition_filter_pair = {
    ctx:ctx_with_result_noquestion f1:preposition_filter 'or' f2:preposition_filter =>
        D.checkFilterPairForDisjunctiveQuestion(ctx, f1, f2);
}
question_pvp_filter_pair = {
    ctx:ctx_with_result_noquestion f1:pvp_filter 'or' f2:pvp_filter =>
        D.checkFilterPairForDisjunctiveQuestion(ctx, f1, f2);
}

disjunctive_slot_fill_question = {
    ( ('are you looking for' | 'would you like' | 'do you need') 'something with' question:question_npp_filter_pair '?'
    | ('are you looking for' | 'would you like' | 'do you need') 'something' question:question_apv_filter_pair '?'
    | ('are you looking for' | 'would you like' | 'do you need') 'something' question:question_preposition_filter_pair '?'
    | ('are you looking for' | 'would you like' | 'do you need') 'something' question:question_pvp_filter_pair '?'
    | ('are you looking for' | 'would you like' | 'do you need') 'something that' question:question_avp_filter_pair '?'
    ) => {
        const [pname, ptype] = question;
        return pname;
    };

    ( ('are you looking for' | 'would you like' | 'do you need') 'a' table:base_table ('with' | 'that has') question:question_npp_filter_pair '?'
    | ('are you looking for' | 'would you like' | 'do you need') 'a' question:question_apv_filter_pair table:base_table '?'
    | ('are you looking for' | 'would you like' | 'do you need') 'a' table:base_table question:question_pvp_filter_pair '?'
    | ('are you looking for' | 'would you like' | 'do you need') 'a' table:base_table question:question_preposition_filter_pair '?'
    | ('are you looking for' | 'would you like' | 'do you need') 'a' table:base_table 'that' question:question_avp_filter_pair '?'
    ) => {
        const [pname, ptype] = question;
        const tableptype = table.schema.getArgType(pname);
        if (!tableptype || !ptype.equals(tableptype) || table.schema.getArgument(pname).getAnnotation('filterable') === false)
            return null;
        return pname;
    };
}

generic_question = {
    'which one would you like ?' => '';
    'do you have a specific one in mind ?' => '';
}

precise_search_question_answer_pair = {
    ( question:direct_slot_fill_question '<sep>' table:generic_answer
    | question:disjunctive_slot_fill_question '<sep>' table:generic_answer
    | question:yesno_direct_slot_fill_question '<sep>' ('yes' | 'yes ,' | '') table:generic_answer

    | question:direct_slot_fill_question '<sep>' table:verbose_answer
    | question:disjunctive_slot_fill_question '<sep>' table:verbose_answer
    | question:yesno_direct_slot_fill_question'<sep>' ('yes' | 'yes ,' | '') table:verbose_answer
    | question:generic_question '<sep>' ('yes' | 'yes ,' | '') table:verbose_answer [weight=0.1]
    ) => {
        if (!D.isQueryAnswerValidForQuestion(table, question))
            return null;
        return [question, table];
    };

    ( preamble:search_result_preamble question:direct_slot_fill_question '<sep>' table:generic_answer [weight=0.1]
    | preamble:search_result_preamble question:disjunctive_slot_fill_question '<sep>' table:generic_answer [weight=0.5]
    | preamble:search_result_preamble question:yesno_direct_slot_fill_question '<sep>' ('yes' | 'yes ,' | '') table:generic_answer [weight=0.1]

    | preamble:search_result_preamble question:direct_slot_fill_question '<sep>' table:verbose_answer [weight=0.1]
    | preamble:search_result_preamble question:disjunctive_slot_fill_question '<sep>' table:verbose_answer [weight=0.1]
    | preamble:search_result_preamble question:yesno_direct_slot_fill_question '<sep>' ('yes' | 'yes ,' | '') table:verbose_answer [weight=0.1]
    | preamble:search_result_preamble question:generic_question '<sep>' ('yes' | 'yes ,' | '') table:verbose_answer [weight=0.01]
    ) => {
        if (!D.isQueryAnswerValidForQuestion(table, question))
            return null;
        return [question, table];
    };
}

imprecise_search_question_answer_pair = {
    ( question:direct_slot_fill_question '<sep>' answer:imprecise_answer
    | question:disjunctive_slot_fill_question '<sep>' answer:imprecise_answer [weight=2]
    | question:yesno_direct_slot_fill_question '<sep>' ('yes' | 'yes ,' | '') answer:imprecise_answer
    ) => D.impreciseSearchQuestionAnswerPair(question, answer);

    ( preamble:search_result_preamble question:direct_slot_fill_question '<sep>' answer:imprecise_answer
    | preamble:search_result_preamble question:disjunctive_slot_fill_question '<sep>' answer:imprecise_answer
    | preamble:search_result_preamble question:yesno_direct_slot_fill_question '<sep>' ('yes' | 'yes ,' | '') answer:imprecise_answer [weight=2]
    ) => D.impreciseSearchQuestionAnswerPair(question, answer);
}

greeting = {
    'hello !';
    'hi !';
}

result_info_phrase = {
    // one, two or three slots, without any "or", "not" or "comparison" filters
    // only "and" and "contains"
    // and furthermore, if the context is a projection, all projected fields must
    // appear as filters
    ctx:ctx_with_result table:one_with_info_phrase [weight=0.33*2] => D.checkInfoPhrase(ctx, table);
    ctx:ctx_with_result table:one_which_info_phrase [weight=0.33*2] => D.checkInfoPhrase(ctx, table);
    ctx:ctx_with_result table:one_clean_info_phrase [weight=0.33*2] => D.checkInfoPhrase(ctx, table);

    ctx:ctx_with_result table:two_with_info_phrase [weight=0.33] => D.checkInfoPhrase(ctx, table);
    ctx:ctx_with_result table:two_which_info_phrase [weight=0.33] => D.checkInfoPhrase(ctx, table);
    ctx:ctx_with_result table:two_clean_info_phrase [weight=0.33] => D.checkInfoPhrase(ctx, table);

    ctx:ctx_with_result table:three_with_info_phrase [weight=0.33*0.5] => D.checkInfoPhrase(ctx, table);
    ctx:ctx_with_result table:three_which_info_phrase [weight=0.33*0.5] => D.checkInfoPhrase(ctx, table);
    ctx:ctx_with_result table:three_clean_info_phrase [weight=0.33*0.5] => D.checkInfoPhrase(ctx, table);
}

the_base_noun_phrase = {
    ( 'the' noun:base_noun_phrase
    | 'that' noun:base_noun_phrase
    ) => noun;
}

for (let [pname, [typestr,]] of _tpLoader.params.in.values()) {
    coref_action_phrase = {
        ( action:thingpedia_action 'it'
        | action:thingpedia_action 'this'
        | action:thingpedia_action 'that'
        ) [-> pname] => {
            const type = action.schema.getArgType(pname);
            if (!type || !type.isEntity)
                return null;
            return action.invocation;
        };

        action:thingpedia_action noun:the_base_noun_phrase [-> pname] => {
            const type = action.schema.getArgType(pname);
            if (!type || !type.isEntity || type.type !== noun)
                return null;
            return action.invocation;
        };
    }

    list_coref_action_phrase = {
        ( action:thingpedia_action 'either one'
        | action:thingpedia_action 'either of them'
        | action:thingpedia_action 'any of them'
        | action:thingpedia_action 'any one of them'
        ) [-> pname] => {
            const type = action.schema.getArgType(pname);
            if (!type || !type.isEntity)
                return null;
            return action.invocation;
        };
    }

    direct_action_phrase = {
        action:thingpedia_action name:constant_name [-> pname { isConstant: true }] =>
            C.replacePlaceholderWithConstant(action, pname, name);
    }
}

question_system_direct_proposal_short = {
    ctx:ctx_with_result_and_action 'how about' proposal:constant_name
        => D.makeRecommendation(ctx, proposal);
}

action_recommendation = {
    /* FIXME I don't really like this template to be honest
    ctx:ctx_with_result_noquestion 'would you like to' action:direct_action_phrase if complete [weight=0.1]
        => D.makeActionRecommendation(ctx, action.invocation);
    */
}

actionable_system_direct_proposal_short = {
    ( ctx:ctx_with_result_and_action 'i' ('recommend' | 'suggest') proposal:constant_name
    | ctx:ctx_with_result_noquestion ('i see' | 'i have' | 'i have found') proposal:constant_name
    ) => D.makeRecommendation(ctx, proposal);
}

user_question_answer_begin = {
    ctx:ctx_with_result_question proposal:constant_name
        => D.makeRecommendation(ctx, proposal);
}

action_offer = {
    ( 'would you like to' action:coref_action_phrase '?'
    | 'would you like me to' action:coref_action_phrase ' for you ?'
    ) if complete => action.invocation;
}

learn_more_offer = {
    'would you like to learn more ?';
    'would you like to know more about it ?';
    'would you like to hear more about it ?';
    'are you interested to hear more about it ?';
}

proposal_info_action_pair = {
    'is a' info:result_info_phrase '.' action:action_offer [weight=0.8] => {
        const resultType = info.schema.getArgType('id');

        if (!resultType || !C.hasArgumentOfType(action, resultType))
            return null;
        return [info, action];
    };

    'is a' info:result_info_phrase '.' learn_more_offer [weight=0.2] => {
        return [info, null];
    };
}

// a recommendation ("direct proposal") consists of the first result of the current query,
// and action to do with it
// the action can come from the context (if the user expressed it earlier), or it can
// be offered immediately
system_direct_proposal = {
    /* FIXME making a recommendation without saying anything about it seems weird?
    ( ctx_with_action proposal:question_system_direct_proposal_short '.' [weight=10]
    | ctx_with_action proposal:actionable_system_direct_proposal_short '.'
    ) => proposal;
    */

    ctx_with_action proposal:actionable_system_direct_proposal_short '.' learn_more_offer => {
        // reset the action to null if the agent explicitly asks to "learn more"
        const { topResult, info } = proposal;
        return { topResult, info, action: null };
    };

    ctx_without_projection proposal:action_recommendation => proposal;
    ctx_without_projection proposal:actionable_system_direct_proposal_short action:action_offer
        => D.checkActionForRecommendation(proposal, action);

    // recommendations after a search
    ( proposal:question_system_direct_proposal_short '?' 'it is a' info:result_info_phrase '.' [weight=10]
    | proposal:action_recommendation '?' 'it is a' info:result_info_phrase '.' [weight=5]
    | proposal:actionable_system_direct_proposal_short '.' 'it is a' info:result_info_phrase '.' [weight=5]
    | proposal:question_system_direct_proposal_short ', which is a' info:result_info_phrase '?' [weight=10]
    | proposal:action_recommendation ', which is a' info:result_info_phrase '?' [weight=5]
    | proposal:actionable_system_direct_proposal_short ', which is a' info:result_info_phrase '.'
    ) => D.checkRecommendation(proposal, info);

    // long-form answers to a single question
    proposal:user_question_answer_begin 'is a' info:result_info_phrase '.'
        => D.checkRecommendation(proposal, info);

    // short answers to a single question
    ( proposal:user_question_answer_begin filter:avp_filter '.'
    | proposal:user_question_answer_begin 'is' filter:pvp_filter '.'
    | proposal:user_question_answer_begin 'is' filter:apv_filter '.'
    | proposal:user_question_answer_begin 'has' filter:npp_filter '.'
    ) => D.makeShortUserQuestionAnswer(proposal, filter);

    // recommendations after a search, followed by an offer to make an action
    ( proposal:actionable_system_direct_proposal_short '. it' pair:proposal_info_action_pair
    | proposal:user_question_answer_begin pair:proposal_info_action_pair
    ) => {
        const [info, action] = pair;
        proposal = D.checkRecommendation(proposal, info);
        if (proposal === null)
            return null;
        const { topResult, } = proposal;
        // reset the action to null if the agent explicitly asks to "learn more"
        if (action === null)
            return { topResult, info, action: null };
        return D.checkActionForRecommendation(proposal, action);
    };
}

result_name_pair = {
    ctx:ctx_with_result n1:constant_name ',' n2:constant_name => {
        const results = ctx.results;
        assert(results.length > 0);
        if (results.length < 2)
            return null;
        if (!ctx.resultInfo.hasID)
            return null;

        const r1 = results[0];
        const r2 = results[1];
        if (!r1.value.id.equals(n1) || !r2.value.id.equals(n2))
            return null;
        return results.slice(0, 2);
    };
}

result_name_list = {
    ctx:ctx_with_result n1:constant_name ('and' | 'or') n2:constant_name => {
        const results = ctx.results;
        assert(results.length > 0);
        if (results.length < 2)
            return null;
        if (!ctx.resultInfo.hasID)
            return null;

        const r1 = results[0];
        const r2 = results[1];
        if (!r1.value.id.equals(n1) || !r2.value.id.equals(n2))
            return null;
        return results.slice(0, 2);
    };

    ctx:ctx_with_result result_name_pair ('and' | 'or') n3:constant_name => {
        const results = ctx.results;
        assert(results.length > 0);
        if (results.length < 3)
            return null;
        if (!ctx.resultInfo.hasID)
            return null;
        const r3 = results[2];
        if (!r3.value.id.equals(n3))
            return null;
        return results.slice(0, 3);
    };
}

action_coref_proposal = {
    ctx_without_projection 'would you like to' action:list_coref_action_phrase '?' => action;
}

// a "list proposal" consists of the first few results of the current query,
// together with informative results about them, an offer to learn more, or an offer for an action
//
system_list_proposal = {
    ctx:ctx_without_projection ('i see' | 'i have' | 'i have found') name_list:result_name_list '.'
        ('' |
         'would you like to learn more ?' | 'would you like to learn more about either of them ?' |
         'would you like to know more about them ?' | 'would you like to hear more about them ?' |
         'are you interested to hear more about any of them ?')
        => [name_list, null, ctx.nextInfo && ctx.nextInfo.isAction ? D.getActionInvocation(ctx.next) : null];

    ctx:ctx_complete_search_command ('i see' | 'i have' | 'i have found') name_list:result_name_list '.' ('they' | 'all of them') 'are' info:result_info_phrase '.'
        => D.checkListProposal(ctx, name_list, info);

    ctx:ctx_complete_search_command  ('i see' | 'i have' | 'i have found') name_list:result_name_list '.' 'both are' info:result_info_phrase '.' => {
        if (name_list.length !== 2)
            return null;
        return D.checkListProposal(ctx, name_list, info);
    };

    ctx:ctx_complete_search_command ('i see' | 'i have' | 'i have found') name_list:result_name_list '.' action:action_coref_proposal => {
        const resultType = name_list[0].value.id.getType();
        if (!C.hasArgumentOfType(action, resultType))
            return null;
        const ctxAction = ctx.nextInfo && ctx.nextInfo.isAction ? D.getActionInvocation(ctx.next) : null;
        if (ctxAction && !C.isSameFunction(ctxAction.schema, action.schema))
            return null;

        return [name_list, null, action];
    };
}

negative_proposal_answer_preamble = {
    'i need';
    'i was thinking more of';
    'i would like';
    'i would like';
    'i am looking for';
    'do you have';
    'can you find';
    'is there';
    'that does not sound great , do you have';
}

generic_negative_proposal_reply = {
    'i do not like that';
    'i do not like that , do you have any other option ?';
}

system_generic_proposal = {
    ( ctx:ctx_search_command ('are you looking for a' | 'how about a' | 'how about the') proposal:answer_noun_phrase '?'
    | ctx:ctx_search_command ('are you looking for' | 'how about') proposal:anything_phrase '?'
    ) => D.makeRefinementProposal(ctx, proposal);

    ( ctx:search_result_preamble ('are you looking for a' | 'how about a' | 'how about the') proposal:answer_noun_phrase '?'
    | ctx:search_result_preamble ('are you looking for' | 'how about' | 'how about') proposal:anything_phrase '?'
    ) => D.makeRefinementProposal(ctx, proposal);
}

accept_phrase = {
    'i like that';
    'yes i like that';
    'sure i like that';
    'sounds good';
}

tell_me_more_phrase = {
    'can you tell me more ?';
    'can you tell me more about it ?';
    'can you give me more info ?';
    'give me more info !';
    'give me more information .';
    'tell me more .';
}

verbose_negative_list_proposal_reply_pair = {
    ( prop:system_list_proposal '<sep>' ('no ,' | 'no' | '') ('i am not in the mood for a' | 'i do not like' | 'i do not want') phrase:answer_noun_phrase
    | prop:system_list_proposal '<sep>' ('no ,' | 'no' | '') ('i am not in the mood for' | 'i do not like' | 'i do not want') phrase:anything_phrase
    ) => {
        const [results, info, action] = prop;
        if (info === null)
            return null;
        if (!D.isValidNegativePreambleForInfo(info, phrase))
            return null;
        return [results, action, phrase];
    };
}

negative_list_proposal_reply_pair = {
    ( prop:system_list_proposal '<sep>' ('no ,' | 'no' | '') negative_proposal_answer_preamble ('a' | 'any') request:answer_noun_phrase
    | prop:system_list_proposal '<sep>' ('no ,' | 'no' | '') negative_proposal_answer_preamble request:anything_phrase
    ) => {
        const [results, info, action] = prop;
        const proposalType = results[0].value.id.getType();
        const idType = request.schema.getArgType('id');

        if (!idType || !idType.equals(proposalType))
            return null;
        return [results, action, request];
    };

    pair:verbose_negative_list_proposal_reply_pair [weight=5] => {
        const [results, action, preamble] = pair;
        // convert the preamble into a request by negating it
        const clone = preamble.clone();
        clone.filter = new Ast.BooleanExpression.Not(null, clone.filter);
        return [results, action, clone];
    };

    ( pair:verbose_negative_list_proposal_reply_pair negative_proposal_answer_preamble ('a' | 'any') request:answer_noun_phrase
    | pair:verbose_negative_list_proposal_reply_pair negative_proposal_answer_preamble request:anything_phrase
    ) => D.mergePreambleAndRequest(pair, request);
}

positive_list_proposal_reply_pair = {
    ( prop:system_list_proposal '<sep>' ('ok' | 'yeah' | '') ('i like' | 'i am interested in' | 'i am intrigued by') name:constant_name '.' [weight=0.5]
    | prop:system_list_proposal '<sep>' ('ok' | 'yeah' | '') name:constant_name 'sounds' ('good' | 'really good' | 'nice' | 'interesting') '.' [weight=0.5]
    ) => {
        const [results, info, actionProposal] = prop;
        let good = false;
        for (let result of results) {
            if (result.value.id.equals(name)) {
                good = true;
                break;
            }
        }
        if (!good)
            return false;

        return [results, actionProposal, name, actionProposal];
    };

    prop:system_list_proposal '<sep>' ('ok' | 'yeah' | '') ('i will go' | 'i will take' | 'i am good for') name:constant_name '.' => {
        const [results, info, actionProposal] = prop;
        if (actionProposal === null)
            return null;
        let good = false;
        for (let result of results) {
            if (result.value.id.equals(name)) {
                good = true;
                break;
            }
        }
        if (!good)
            return false;

        return [results, actionProposal, name, actionProposal];
    };

    ( prop:system_list_proposal '<sep>' ('ok' | 'yeah' | '') 'can you tell me more about' name:constant_name '?' [weight=0.33]
    | prop:system_list_proposal '<sep>' ('ok' | 'yeah' | '') ('i like' | 'i am interested in' | 'i am intrigued by') name:constant_name '.' tell_me_more_phrase [weight=0.33]
    | prop:system_list_proposal '<sep>' ('ok' | 'yeah' | '') name:constant_name 'sounds' ('good' | 'really good' | 'nice' | 'interesting') '.' tell_me_more_phrase [weight=0.33]
    ) => {
        const [results, info, actionProposal] = prop;
        let good = false;
        for (let result of results) {
            if (result.value.id.equals(name)) {
                good = true;
                break;
            }
        }
        if (!good)
            return false;

        // set the action to null, which will hit the "tell me more" path
        return [results, actionProposal, name, null];
    };
}

user_search_question_with_name = {
    // straight up questions
    ( ('can you tell me' | '') 'what is' name:constant_name '\'s' param:out_param_Any '?'
    | ('can you tell me' | '') 'what is' 'the' param:out_param_Any 'of' name:constant_name '?'
    | 'can you tell me' name:constant_name '\'s' param:out_param_Any '?'
    | 'can you tell me' 'the' param:out_param_Any 'of' name:constant_name '?'
    | 'i would like to' ('know' | 'see') name:constant_name '\'s' param:out_param_Any ('first' | '') '.'
    | 'i would like to' ('know' | 'see') 'the' param:out_param_Any 'of' name:constant_name ('first' | '') '.'
    ) => {
        if (param.name === 'id')
            return null;
        return [name, param.name, null];
    };
}

boolean_user_search_question_with_name = {
    // question in boolean
    ( 'does' name:constant_name 'have' param:npp_filter '?'
    | 'does' name:constant_name param:avp_filter '?'
    | 'is' name:constant_name param:apv_filter '?'
    | 'is' name:constant_name param:pvp_filter '?'
    | 'is' name:constant_name param:preposition_filter '?'
    ) => {
        if (param.name === 'id')
            return null;
        return [name, param.name, param.operator === 'contains' ? Type.Array(param.value.getType()) : param.value.getType()];
    };

    ( 'is' name:constant_name 'a' param:apv_filter base:base_table '?'
    | 'is' name:constant_name 'a' base:base_table param:pvp_filter '?'
    | 'is' name:constant_name 'a' base:base_table param:preposition_filter '?'
    | 'is' name:constant_name 'a' base:base_table ('that' | 'which') param:avp_filter '?'
    | 'is' name:constant_name 'a' base:base_table ('that has' | 'with') param:npp_filter '?'
    ) => {
        if (!C.checkFilter(base, param))
            return null;
        if (param.name === 'id')
            return null;
        const idArg = base.schema.getArgument('id');
        if (!idArg || !idArg.type.equals(name.getType()))
            return null;
        return [param.name, param.operator === 'contains' ? Type.Array(param.value.getType()) : param.value.getType()];
    };
}

list_proposal_search_question_pair = {
    ( prop:system_list_proposal '<sep>' question:user_search_question_with_name
    | prop:system_list_proposal '<sep>' question:boolean_user_search_question_with_name
    ) => {
        const [name, pname, type] = question;
        const [results, info, action] = prop;
        let good = false;
        for (let result of results) {
            if (!result.value.id)
                continue;
            if (result.value.id.equals(name)) {
                good = true;
                break;
            }
        }
        if (!good)
            return null;

        if (info !== null) {
            if (info.has(pname))
                return null;
            if (!info.schema.hasArgument(pname))
                return null;
            if (type !== null && !info.schema.getArgType(pname).equals(type))
                return null;
        }
        return [results, name, action, [pname, type]];
    };
}

verbose_negative_proposal_reply_pair = {
    /* FIXME
    ( prop:system_generic_proposal '<sep>' ('no ,' | 'no' | '') ('i am not in the mood for a' | 'i do not like' | 'i do not want') phrase:answer_noun_phrase
    | prop:system_generic_proposal '<sep>' ('no ,' | 'no' | '') ('i am not in the mood for' | 'i do not like' | 'i do not want') phrase:anything_phrase
    ) => {
        if (!D.isValidNegativePreambleForInfo(prop, preamble))
            return null;
        return [prop, preamble];
    };
    */
}

negative_proposal_reply_pair = {
    ( prop:system_generic_proposal '<sep>' ('no ,' | 'no' | '') negative_proposal_answer_preamble ('a' | 'any') request:answer_noun_phrase
    | prop:system_generic_proposal '<sep>' ('no ,' | 'no' | '') negative_proposal_answer_preamble request:anything_phrase
    | prop:system_generic_proposal '<sep>' ('no ,' | 'no' | '') request:generic_answer
    ) => {
        if (!C.isSameFunction(prop.schema, request.schema))
            return null;
        const refined = D.refineFilterToChangeFilter(prop.filter, request.filter);
        if (refined === null)
            return null;
        return [prop, request];
    };

    pair:verbose_negative_proposal_reply_pair [weight=5] => {
        const [prop, preamble] = pair;
        // convert the preamble into a request by negating it
        const clone = preamble.clone();
        clone.filter = new Ast.BooleanExpression.Not(null, clone.filter);
        return [prop, clone];
    };

    ( pair:verbose_negative_proposal_reply_pair negative_proposal_answer_preamble ('a' | 'any') request:answer_noun_phrase
    | pair:verbose_negative_proposal_reply_pair negative_proposal_answer_preamble request:anything_phrase
    ) => D.mergePreambleAndRequest(pair, request);
}

positive_proposal_reply_pair = {
    prop:system_generic_proposal '<sep>' accept_phrase => [prop, prop];
}

verbose_negative_recommendation_reply_pair = {
    ( prop:system_direct_proposal '<sep>' ('no ,' | 'no' | '') ('i am not in the mood for a' | 'i do not like' | 'i do not want') phrase:answer_noun_phrase
    | prop:system_direct_proposal '<sep>' ('no ,' | 'no' | '') ('i am not in the mood for' | 'i do not like' | 'i do not want') phrase:anything_phrase
    ) => {
        const { topResult, info, action } = prop;
        if (info === null || !D.isValidNegativePreambleForInfo(info, phrase))
            return null;
        return [topResult, action, phrase];
    };
}

negative_recommendation_reply_pair = {
    ( prop:system_direct_proposal '<sep>' ('no ,' | 'no' | '') negative_proposal_answer_preamble ('a' | 'any') request:answer_noun_phrase
    | prop:system_direct_proposal '<sep>' ('no ,' | 'no' | '') negative_proposal_answer_preamble request:anything_phrase
    ) => {
        const { topResult, action } = prop;
        const proposalType = topResult.value.id.getType();
        const idType = request.schema.getArgType('id');

        if (!idType || !idType.equals(proposalType))
            return null;
        return [topResult, action, request];
    };

    pair:verbose_negative_recommendation_reply_pair [weight=5] => {
        const [topResult, action, preamble] = pair;
        // convert the preamble into a request by negating it
        const clone = preamble.clone();
        clone.filter = new Ast.BooleanExpression.Not(null, clone.filter);
        return [topResult, action, clone];
    };

    ( pair:verbose_negative_recommendation_reply_pair negative_proposal_answer_preamble ('a' | 'any') request:answer_noun_phrase
    | pair:verbose_negative_recommendation_reply_pair negative_proposal_answer_preamble request:anything_phrase
    ) => D.mergePreambleAndRequest(pair, request);
}

positive_recommendation_reply_pair = {
    prop:system_direct_proposal '<sep>' accept_phrase [repeat=true] => {
        const { topResult, action: actionProposal } = prop;
        // if the user did not give an action earlier, and no action
        // was proposed by the agent right now, the flow is roughly
        //
        // U: hello i am looking for a restaurant
        // A: how about the ... ?
        // U: sure I like that
        //
        // this doesn't make much sense, so we don't want this flow
        if (actionProposal === null)
            return null;

        return [topResult, actionProposal, actionProposal];
    };

    ( prop:system_direct_proposal '<sep>' tell_me_more_phrase [weight=0.5]
    | prop:system_direct_proposal '<sep>' accept_phrase tell_me_more_phrase [weight=0.5]
    ) => {
        const { topResult, action: actionProposal } = prop;
        // set the action to null, which will hit the "tell me more" path
        return [topResult, actionProposal, null];
    };
}

simple_user_search_question = {
    // straight up questions
    ( ('can you tell me' | '') 'what is' ('the' | 'its') param:out_param_Any '?'
    | 'can you tell me' ('the' | 'its') param:out_param_Any '?'
    | ('can you tell me' | '') 'what' param:out_param_Any 'does it have ?'
    | 'i would like to' ('know' | 'see') ('the' | 'its') param:out_param_Any ('first' | '') '.'
    ) => {
        if (param.name === 'id')
            return null;
        return [param.name, null];
    };
    ( ('can you tell me' | '') 'what is' 'the' param:out_param_Any 'of the' base:base_table '?'
    | 'can you tell me' 'the' param:out_param_Any 'of the' base:base_table '?'
    | ('can you tell me' | '') 'what' param:out_param_Any 'does the' base:base_table 'have ?'
    | 'i would like to' ('know' | 'see') 'the' param:out_param_Any 'of the' base:base_table ('first' | '') '.'
    | ('can you tell me' | '') 'what is' 'the' base:base_table '\'s' param:out_param_Any '?'
    | 'can you tell me' 'the' base:base_table '\'s' param:out_param_Any '?'
    | 'i would like to' ('know' | 'see') 'the' base:base_table '\'s' param:out_param_Any ('first' | '') '.'
    ) => {
        if (!base.schema.out[param.name])
            return null;
        if (param.name === 'id')
            return null;
        return [param.name, null];
    };
}

boolean_user_search_question = {
    // question in boolean
    ( 'does' ('that' | 'it') 'have' param:npp_filter '?'
    | 'does' ('that' | 'it') param:avp_filter '?'
    ) => {
        if (param.name === 'id')
            return null;
        return [param.name, param.operator === 'contains' ? Type.Array(param.value.getType()) : param.value.getType()];
    };

    ( 'is' ('it' | 'that') 'a' param:apv_filter base:base_table '?'
    | 'is that' base:base_table param:apv_filter '?'

    | 'is' ('it' | 'that') 'a' base:base_table param:pvp_filter '?'
    | 'is that' base:base_table param:pvp_filter '?'

    | 'is' ('it' | 'that') 'a' base:base_table param:preposition_filter '?'
    | 'is that' base:base_table param:preposition_filter '?'

    | 'is' ('it' | 'that') 'a' base:base_table ('that' | 'which') param:avp_filter '?'
    | 'does that' base:base_table param:avp_filter '?'

    | 'is' ('it' | 'that') 'a' base:base_table ('that has' | 'with') param:npp_filter '?'
    | 'does that' base:base_table 'have' param:npp_filter '?'
    ) => {
        if (!C.checkFilter(base, param))
            return null;
        if (param.name === 'id')
            return null;
        return [param.name, param.operator === 'contains' ? Type.Array(param.value.getType()) : param.value.getType()];
    };
}

recommendation_search_question_pair = {
    ( prop:system_direct_proposal '<sep>' question:simple_user_search_question
    | prop:system_direct_proposal '<sep>' question:boolean_user_search_question
    ) => {
        const [pname, type] = question;
        const { topResult, info, action } = prop;
        if (info !== null) {
            if (info.has(pname))
                return null;
            if (!info.schema.hasArgument(pname))
                return null;
            if (type !== null && !info.schema.getArgType(pname).equals(type))
                return null;
        }
        return [topResult, action, question];
    };
}

learn_more_search_question_pair = {
    ( 'what would you like to' ('know' | 'hear') '?' '<sep>' question:simple_user_search_question
    | 'what would you like to' ('know' | 'hear') '?' '<sep>' question:boolean_user_search_question
    ) => {
        return [null, null, question];
    };
}

empty_search_error = {
    ('sorry ,' | 'i am sorry ,' | '') ('there are no' | 'i cannot find any') base:base_table ('matching your request' | 'with those characteristics' | 'like that')
    '.' => [base, null];

    ('sorry ,' | 'i am sorry ,' | '') ('there are no' | 'i cannot find any') base:base_table ('matching your request' | 'with those characteristics' | 'like that')
    '.' 'would you like' ('a different' | 'another') p:out_param_Any '?' => {
        if (!base.schema.hasArgument(p))
            return null;
        return [base, p];
    };

    ('sorry ,' | 'i am sorry ,' | '') 'i cannot find any result for your search . would you like' ('a different' | 'another') p:out_param_Any '?'
        => [null, p];
}

empty_search_change_pair = {
    ( error:empty_search_error '<sep>' ('i see ,' | 'okay' | 'okay ,' | 'yeah' | 'yeah ,') ('do you have' | 'can you find' | 'is there' | 'how about') 'a' phrase:answer_noun_phrase '?'
    | error:empty_search_error '<sep>' ('i see ,' | 'okay' | 'okay ,' | 'yeah' | 'yeah ,') ('do you have' | 'can you find' | 'is there' | 'how about') phrase:anything_phrase '?'
    ) => {
        const [base, param] = error;
        if (base !== null && !C.isSameFunction(base.schema, phrase.schema))
            return null;
        if (param !== null && !C.filterUsesParam(phrase.filter, param.name))
            return null;
        return [param, phrase];
    };

    error:empty_search_error '<sep>' ('i see ,' | 'okay' | 'okay ,' | 'yeah' | 'yeah ,') ('do you have' | 'can you find' | 'is there' | 'how about') answer:imprecise_answer_phrase '?' => {
        const [base, param] = error;
        if (base === null || param === null)
            return null;
        if (answer instanceof Ast.Value)
            answer = C.makeFilter(param, '==', answer);
        if (answer === null)
            return null;
        if (answer.name !== param.name)
            return null;
        if (!C.checkFilter(base, answer))
            return null;
        return [param, new Ast.Table.Filter(null, base, answer, base.schema)];
    };
}

initial_command = {
    action_command [weight=3];
    search_command;
    complete_question [weight=0.1];
    projection_question [weight=0.1];

    prog:initial_program => {
        if (prog.rules.length !== 1)
            return null;
        return prog.rules[0];
    };
}

$root = {
    /*ctx:ctx_init greeting [weight=0.01] =>
        D.checkStateIsValid(ctx, null, new Ast.DialogueState(null, D.POLICY_NAME, 'greet', null, []));
    */

    ( ctx:ctx_init stmt:initial_command [weight=0.5]
    | ctx:ctx_init greeting stmt:initial_command [weight=0.5]
    ) => {
        const userState = D.initialRequest(stmt);
        if (userState === null)
            return null;
        return D.checkStateIsValid(ctx, null, userState);
    };

    ctx:ctx_greet ('hello' | 'hi') ('!' | ',') ('how can i help you' | 'what are you interested in' | 'what can i do for you') '?' '<sep>' stmt:initial_command => {
        const userState = D.initialRequest(stmt);
        if (userState === null)
            return null;
        const sysState = D.makeSimpleState(ctx, 'sys_greet', null);
        return D.checkStateIsValid(ctx, sysState, userState);
    };

    // empty search error
    ctx:ctx_empty_search_command pair:empty_search_change_pair
        => D.emptySearchChangePair(ctx, pair);

    // query refinement (through proposal or slot fill)
    ctx:ctx_search_command qa:precise_search_question_answer_pair [weight=5] =>
        D.preciseSearchQuestionAnswer(ctx, qa);
    ctx:ctx_search_command qa:imprecise_search_question_answer_pair [weight=5] =>
        D.impreciseSearchQuestionAnswer(ctx, qa);
    ( ctx:ctx_search_command pair:negative_proposal_reply_pair [weight=0.5]
    | ctx:ctx_search_command pair:positive_proposal_reply_pair [weight=0.5]
    ) =>
        D.proposalReplyPair(ctx, pair);

    // action recommendation (through one or a list)

    // FIXME should be "ctx_single_result_search_command" but we don't generate enough
    // of those so let's stick to complete_search_command for now
    ctx:ctx_complete_search_command pair:negative_recommendation_reply_pair [weight=0.3]
        => D.negativeRecommendationReplyPair(ctx, pair);
    ctx:ctx_complete_search_command pair:positive_recommendation_reply_pair [weight=0.7]
        => D.positiveRecommendationReplyPair(ctx, pair);
    ctx:ctx_complete_search_command pair:recommendation_search_question_pair [weight=1]
        => D.recommendationSearchQuestionPair(ctx, pair);
    ctx:ctx_learn_more pair:learn_more_search_question_pair [weight=1]
        => D.recommendationSearchQuestionPair(ctx, pair);

    ctx:ctx_complete_search_command pair:negative_list_proposal_reply_pair [weight=10 * 0.3]
        => D.negativeListProposalReplyPair(ctx, pair);
    ctx:ctx_complete_search_command pair:positive_list_proposal_reply_pair [weight=10 * 0.7]
        => D.positiveListProposalReplyPair(ctx, pair);
    ctx:ctx_complete_search_command pair:list_proposal_search_question_pair [weight=10]
        => D.listProposalSearchQuestionPair(ctx, pair);
}
