// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2017-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details

{
    const assert = require('assert');
    const ThingTalk = require('thingtalk');
    const Ast = ThingTalk.Ast;

    const C = require('../ast_manip');
    const D = require('../dialogue_utils');

    // import thingpedia info
    const _tpLoader = require('../load-thingpedia');
}

import '../common';
import './constants';
import './timers';
import './filters';
import './parameters';
import './aggregation';
import './computation';
import './who_questions';
import './stream_tables';
import './commands';

context ctx_init,
    ctx_greet,
    ctx_with_result,
    ctx_with_action,
    ctx_with_result_and_action,
    ctx_with_projection,
    ctx_without_projection,
    ctx_search_command,
    ctx_empty_direct_question,
    ctx_aggregation_question,
    ctx_distance_argminmax_question,
    ctx_argminmax_question,
    ctx_one_result_question,
    ctx_empty_search_command,
    ctx_large_search_command,
    ctx_complete_search_command,
    ctx_completed_action,
    ctx_confirm_action,
    ctx_incomplete_action,
    ctx_learn_more;

context function (state) {
    if (state === null)
        return [['ctx_init'], D.INITIAL_CONTEXT_INFO];
    if (!(state instanceof Ast.DialogueState))
        console.error(state);
    assert(state instanceof Ast.DialogueState);
    if (state.policy !== D.POLICY_NAME)
        return null;
    const info = D.getContextInfo(state);

    switch (state.dialogueAct) {
    case 'greet':
        assert(state.history.length === 0, `expected empty history for greet`);
        return [['ctx_greet'], info];

    case 'execute': {
        const tags = [];

        if (info.nextInfo !== null) {
            // we have an action we want to execute, or a query that needs confirmation
            if (info.nextInfo.chainParameter === null || info.nextInfo.chainParameterFilled) {
                // we don't need to fill any parameter from the current query

                if (info.nextInfo.isComplete) {
                    return [['ctx_confirm_action'], info];
                } else {
                    return [['ctx_incomplete_action'], info];
                }
            }

            tags.push('ctx_with_action');
        }

        // we must have a result
        assert(info.resultInfo);
        // nothing else is implemented.
        assert (info.resultInfo.isTable);

        if (info.resultInfo.hasEmptyResult) {
            if (info.resultInfo.isQuestion)
                tags.push('ctx_empty_direct_question');
            else
                tags.push('ctx_empty_search_command');
            return [tags, info];
        }

        if (info.nextInfo)
            tags.push('ctx_with_result_and_action');
        tags.push('ctx_with_result');

        if (info.resultInfo.projection === null)
            tags.push('ctx_without_projection');
        else
            tags.push('ctx_with_projection');

        // if there is an action, there cannot be a projection
        assert(info.resultInfo.projection === null || info.nextInfo === null);

        if (info.resultInfo.isQuestion) {
            if (info.resultInfo.isAggregation) {
                // "how many restaurants nearby have more than 500 reviews?"
                tags.push('ctx_aggregation_question');
            } else if (info.resultInfo.argMinMaxField !== null) {
                const [field, direction] = info.resultInfo.argMinMaxField;

                if (field === 'distance') // "find the nearest starbucks"
                    tags.push('ctx_distance_argminmax_question');
                else // "what is the highest rated restaurant nearby?"
                    tags.push('ctx_argminmax_question');
            } else if (info.resultInfo.hasSingleResult) {
                // "what is the rating of Terun?"
                tags.push('ctx_one_result_question');
            } else {
                // "what's the food and price range of restaurants nearby?"
                // we treat these the same as "find restaurants nearby", but we make sure
                // that the necessary fields are computed
                tags.push('ctx_search_command');

                // we can recommend/show the result right away, even if many match
                tags.push('ctx_complete_search_command');
            }
        } else {
            if (!info.resultInfo.hasSingleResult) // we can refine
                tags.push('ctx_search_command');

            if (!info.resultInfo.hasLargeResult) // we can recommend/show the result
                tags.push('ctx_complete_search_command');
        }

        return [tags, info];
    }

    case 'learn_more':
        return ['ctx_learn_more'];

    default:
        throw new Error(`Unexpected user dialogue act ${info.dialogueAct}`);
    }
}

search_result_preamble = {
    ctx:ctx_search_command ('there are' | 'i can see' | 'i have found' | 'i can recommend') ('many' | 'several') base:base_noun_phrase
        ('matching your request' | 'matching your constraints' | 'with those characteristics' | 'like that' | '') '.'
        => D.checkSearchResultPreamble(ctx, base, null, false);

    ctx:ctx_search_command ('there are' | 'i have found' | 'i have' | 'i can see') num:constant_Number base:base_noun_phrase
        ('in my database' | 'like that') '.'
        => D.checkSearchResultPreamble(ctx, base, num, false);
}

direct_slot_fill_question = {
    ( 'what' p:out_param_Any 'do you want ?'
    | 'what' p:out_param_Any 'would you prefer ?'
    | 'what' p:out_param_Any 'would you like ?'
    | 'what' p:out_param_Any 'are you interested in ?'
    | 'what' p:out_param_Any 'are you looking for ?'
    ) => {
        if (p.name === 'id')
            return null;
        return p.name;
    };
}

yesno_direct_slot_fill_question = {
    ( 'any preference of' p:out_param_Any '?'
    | 'do you have a specific' p:out_param_Any 'in mind?'
    | 'do you have a preference of' p:out_param_Any '?'
    | 'do you have a preferred' p:out_param_Any '?'
    | 'are you looking for a specific' p:out_param_Any '?'
    ) => {
        if (p.name === 'id')
            return null;
        return p.name;
    };
}

generic_answer = {
    // TODO
}

imprecise_answer_phrase = {
    ( slot:constant_Any
    | slot:npp_filter
    | slot:apv_filter
    | slot:pvp_filter
    | slot:preposition_filter
    ) => slot;
}

imprecise_answer = {
    ans:imprecise_answer_phrase ('please' | '') '.' => ans;

    generic_preamble_for_answer ans:imprecise_answer_phrase '.' => ans;
}

answer_noun_phrase = {
    // one filter
    one_with_filter_table;
    one_which_filter_table;
    one_clean_filter_table;

    // two filters
    two_with_filter_table;
    two_which_filter_table;
    two_clean_filter_table;
}

verbose_answer = {
    // complete answer, like "I am looking for a bla restaurant"
    generic_preamble_for_answer ('a' | 'the') query:answer_noun_phrase => query;
}

question_npp_filter_pair = {
    ctx:ctx_with_result f1:npp_filter 'or' f2:npp_filter =>
        D.checkFilterPairForDisjunctiveQuestion(ctx, f1, f2);
    ctx:ctx_with_result f1:npp_filter 'or' c:constant_Any  =>
        D.checkFilterPairForDisjunctiveQuestion(ctx, f1, new Ast.BooleanExpression.Atom(null, f1.name, f1.operator, c));
}
question_apv_filter_pair = {
    ctx:ctx_with_result f1:apv_filter 'or' f2:apv_filter =>
        D.checkFilterPairForDisjunctiveQuestion(ctx, f1, f2);
}
question_avp_filter_pair = {
    ctx:ctx_with_result f1:avp_filter 'or' c:constant_Any =>
        D.checkFilterPairForDisjunctiveQuestion(ctx, f1, new Ast.BooleanExpression.Atom(null, f1.name, f1.operator, c));
}
question_preposition_filter_pair = {
    ctx:ctx_with_result f1:preposition_filter 'or' f2:preposition_filter =>
        D.checkFilterPairForDisjunctiveQuestion(ctx, f1, f2);
}
question_pvp_filter_pair = {
    ctx:ctx_with_result f1:pvp_filter 'or' f2:pvp_filter =>
        D.checkFilterPairForDisjunctiveQuestion(ctx, f1, f2);
}

disjunctive_slot_fill_question = {
    ( ('are you looking for' | 'would you like' | 'do you need') 'something with' question:question_npp_filter_pair '?'
    | ('are you looking for' | 'would you like' | 'do you need') 'something' question:question_apv_filter_pair '?'
    | ('are you looking for' | 'would you like' | 'do you need') 'something' question:question_preposition_filter_pair '?'
    | ('are you looking for' | 'would you like' | 'do you need') 'something' question:question_pvp_filter_pair '?'
    | ('are you looking for' | 'would you like' | 'do you need') 'something that' question:question_avp_filter_pair '?'
    ) => {
        const [pname, ptype] = question;
        return pname;
    };

    ( ('are you looking for' | 'would you like' | 'do you need') 'a' table:base_table ('with' | 'that has') question:question_npp_filter_pair '?'
    | ('are you looking for' | 'would you like' | 'do you need') 'a' question:question_apv_filter_pair table:base_table '?'
    | ('are you looking for' | 'would you like' | 'do you need') 'a' table:base_table question:question_pvp_filter_pair '?'
    | ('are you looking for' | 'would you like' | 'do you need') 'a' table:base_table question:question_preposition_filter_pair '?'
    | ('are you looking for' | 'would you like' | 'do you need') 'a' table:base_table 'that' question:question_avp_filter_pair '?'
    ) => {
        const [pname, ptype] = question;
        const tableptype = table.schema.getArgType(pname);
        if (!tableptype || !ptype.equals(tableptype))
            return null;
        return pname;
    };
}

generic_question = {
    'which one would you like ?' => '';
    'do you have a specific one in mind ?' => '';
}

precise_search_question_answer_pair = {
    ( question:direct_slot_fill_question '<sep>' table:generic_answer
    | question:disjunctive_slot_fill_question '<sep>' table:generic_answer
    | question:yesno_direct_slot_fill_question '<sep>' ('yes' | 'yes ,' | '') table:generic_answer

    | question:direct_slot_fill_question '<sep>' table:verbose_answer
    | question:disjunctive_slot_fill_question '<sep>' table:verbose_answer
    | question:yesno_direct_slot_fill_question'<sep>' ('yes' | 'yes ,' | '') table:verbose_answer
    | question:generic_question '<sep>' ('yes' | 'yes ,' | '') table:verbose_answer [weight=0.1]
    ) => {
        if (!D.isQueryAnswerValidForQuestion(table, question))
            return null;
        return [question, table];
    };

    ( preamble:search_result_preamble question:direct_slot_fill_question '<sep>' table:generic_answer [weight=0.1]
    | preamble:search_result_preamble question:disjunctive_slot_fill_question '<sep>' table:generic_answer [weight=0.5]
    | preamble:search_result_preamble question:yesno_direct_slot_fill_question '<sep>' ('yes' | 'yes ,' | '') table:generic_answer [weight=0.1]

    | preamble:search_result_preamble question:direct_slot_fill_question '<sep>' table:verbose_answer [weight=0.1]
    | preamble:search_result_preamble question:disjunctive_slot_fill_question '<sep>' table:verbose_answer [weight=0.1]
    | preamble:search_result_preamble question:yesno_direct_slot_fill_question '<sep>' ('yes' | 'yes ,' | '') table:verbose_answer [weight=0.1]
    | preamble:search_result_preamble question:generic_question '<sep>' ('yes' | 'yes ,' | '') table:verbose_answer [weight=0.01]
    ) => {
        if (!D.isQueryAnswerValidForQuestion(table, question))
            return null;
        return [question, table];
    };
}

imprecise_search_question_answer_pair = {
    ( question:direct_slot_fill_question '<sep>' answer:imprecise_answer
    | question:disjunctive_slot_fill_question '<sep>' answer:imprecise_answer [weight=2]
    | question:yesno_direct_slot_fill_question '<sep>' ('yes' | 'yes ,' | '') answer:imprecise_answer
    ) => D.impreciseSearchQuestionAnswerPair(question, answer);

    ( preamble:search_result_preamble question:direct_slot_fill_question '<sep>' answer:imprecise_answer
    | preamble:search_result_preamble question:disjunctive_slot_fill_question '<sep>' answer:imprecise_answer
    | preamble:search_result_preamble question:yesno_direct_slot_fill_question '<sep>' ('yes' | 'yes ,' | '') answer:imprecise_answer [weight=2]
    ) => D.impreciseSearchQuestionAnswerPair(question, answer);
}

greeting = {
    'hello !';
    'hi !';
}

result_info_phrase = {
    // one, two or three slots, without any "or", "not" or "comparison" filters
    // only "and" and "contains"
    // and furthermore, if the context is a projection, all projected fields must
    // appear as filters
    ctx:ctx_with_result table:one_with_filter_table => D.checkInfoFilter(ctx, table);
    ctx:ctx_with_result table:one_which_filter_table => D.checkInfoFilter(ctx, table);
    ctx:ctx_with_result table:one_clean_filter_table => D.checkInfoFilter(ctx, table);

    ctx:ctx_with_result table:two_with_filter_table [weight=0.33] => D.checkInfoFilter(ctx, table);
    ctx:ctx_with_result table:two_which_filter_table [weight=0.33] => D.checkInfoFilter(ctx, table);
    ctx:ctx_with_result table:two_clean_filter_table [weight=0.33] => D.checkInfoFilter(ctx, table);

    ctx:ctx_with_result table:three_with_filter_table [weight=0.33*0.5] => D.checkInfoFilter(ctx, table);
    ctx:ctx_with_result table:three_which_filter_table [weight=0.33*0.5] => D.checkInfoFilter(ctx, table);
    ctx:ctx_with_result table:three_clean_filter_table [weight=0.33*0.5] => D.checkInfoFilter(ctx, table);
}

the_base_noun_phrase = {
    ( 'the' noun:base_noun_phrase
    | 'that' noun:base_noun_phrase
    ) => noun;
}

for (let [pname, [typestr,]] of _tpLoader.params.in.values()) {
    coref_action_phrase = {
        ( action:thingpedia_action 'it'
        | action:thingpedia_action 'this'
        | action:thingpedia_action 'that'
        ) [-> pname] => {
            const type = action.schema.getArgType(pname);
            if (!type || !type.isEntity)
                return null;
            return action.invocation;
        };

        action:thingpedia_action noun:the_base_noun_phrase [-> pname] => {
            const type = action.schema.getArgType(pname);
            if (!type || !type.isEntity || type.type !== noun)
                return null;
            return action.invocation;
        };
    }

    list_coref_action_phrase = {
        ( action:thingpedia_action 'either one'
        | action:thingpedia_action 'either of them'
        | action:thingpedia_action 'any of them'
        | action:thingpedia_action 'any one of them'
        ) [-> pname] => {
            const type = action.schema.getArgType(pname);
            if (!type || !type.isEntity)
                return null;
            return action.invocation;
        };
    }

    direct_action_phrase = {
        action:thingpedia_action name:constant_name [-> pname { isConstant: true }] =>
            C.replacePlaceholderWithConstant(action, pname, name);
    }
}

question_system_direct_proposal_short = {
    ctx:ctx_with_result_and_action 'how about' proposal:constant_name
        => D.makeRecommendation(ctx, proposal);
}

action_recommendation = {
    ctx:ctx_with_result 'would you like to' action:direct_action_phrase if complete [weight=0.1]
        => D.makeActionRecommendation(ctx, action.invocation);
}

actionable_system_direct_proposal_short = {
    ( ctx:ctx_with_result_and_action 'i' ('recommend' | 'suggest') proposal:constant_name
    | ctx:ctx_with_result ('i see' | 'i have' | 'i have found') proposal:constant_name
    | ctx:ctx_with_result 'there is' proposal:constant_name
    ) => D.makeRecommendation(ctx, proposal);
}

action_offer = {
    ( 'would you like to' action:coref_action_phrase '?'
    | 'would you like me to' action:coref_action_phrase ' for you ?'
    ) if complete => action.invocation;
}

learn_more_offer = {
    'would you like to learn more ?';
    'would you like to know more about it ?';
    'would you like to hear more about it ?';
    'are you interested to hear more about it ?';
}

proposal_info_action_pair = {
    'it is a' info:result_info_phrase '.' action:action_offer [weight=0.8] => {
        const resultType = info.schema.getArgType('id');

        if (!resultType || !C.hasArgumentOfType(action, resultType))
            return null;
        return [info, action];
    };

    'it is a' info:result_info_phrase '.' learn_more_offer [weight=0.2] => {
        return [info, null];
    };
}

// a recommendation ("direct proposal") consists of the first result of the current query,
// and action to do with it
// the action can come from the context (if the user expressed it earlier), or it can
// be offered immediately
system_direct_proposal = {
    ( ctx_with_action proposal:question_system_direct_proposal_short '.' [weight=10]
    | ctx_with_action proposal:actionable_system_direct_proposal_short '.'
    ) => proposal;

    ctx_with_action proposal:actionable_system_direct_proposal_short '.' learn_more_offer => {
        // reset the action to null if the agent explicitly asks to "learn more"
        const [topResult,] = proposal;
        return [topResult, null];
    };

    ctx_without_projection action:action_recommendation => action;
    ctx_without_projection proposal:actionable_system_direct_proposal_short action:action_offer
        => D.checkActionForRecommendation(proposal, action);

    ( proposal:question_system_direct_proposal_short '?' 'it is a' info:result_info_phrase '.' [weight=10]
    | proposal:action_recommendation '?' 'it is a' info:result_info_phrase '.'
    | proposal:actionable_system_direct_proposal_short '.' 'it is a' info:result_info_phrase '.'
    | proposal:question_system_direct_proposal_short ', which is a' info:result_info_phrase '?' [weight=10]
    | proposal:action_recommendation ', which is a' info:result_info_phrase '?'
    | proposal:actionable_system_direct_proposal_short ', which is a' info:result_info_phrase '.'
    ) => D.checkRecommendation(proposal, info);

    proposal:actionable_system_direct_proposal_short '.' pair:proposal_info_action_pair => {
        const [info, action] = pair;
        proposal = D.checkRecommendation(proposal, info);
        if (proposal === null)
            return null;
        const [topResult,] = proposal;
        // reset the action to null if the agent explicitly asks to "learn more"
        if (action === null)
            return [topResult, null];
        return D.checkActionForRecommendation(proposal, action);
    };
}

result_name_pair = {
    ctx:ctx_with_result n1:constant_name ',' n2:constant_name => {
        const results = ctx.current.results.results;
        assert(results.length > 0);
        if (results.length < 2)
            return null;
        if (!ctx.resultInfo.hasID)
            return null;

        const r1 = results[0];
        const r2 = results[1];
        if (!r1.value.id.equals(n1) || !r2.value.id.equals(n2))
            return null;
        return results.slice(0, 2);
    };
}

result_name_list = {
    ctx:ctx_with_result n1:constant_name ('and' | 'or') n2:constant_name => {
        const results = ctx.current.results.results;
        assert(results.length > 0);
        if (results.length < 2)
            return null;
        if (!ctx.resultInfo.hasID)
            return null;

        const r1 = results[0];
        const r2 = results[1];
        if (!r1.value.id.equals(n1) || !r2.value.id.equals(n2))
            return null;
        return results.slice(0, 2);
    };

    ctx:ctx_with_result result_name_pair ('and' | 'or') n3:constant_name => {
        const results = ctx.current.results.results;
        assert(results.length > 0);
        if (results.length < 3)
            return null;
        if (!ctx.resultInfo.hasID)
            return null;
        const r3 = results[2];
        if (!r3.value.id.equals(n3))
            return null;
        return results.slice(0, 3);
    };
}

action_coref_proposal = {
    ctx_without_projection 'would you like to' action:list_coref_action_phrase '?' => action;
}

// a "list proposal" consists of the first few results of the current query,
// together with informative results about them, an offer to learn more, or an offer for an action
//
system_list_proposal = {
    ctx_without_projection ('i see' | 'i have' | 'i have found') name_list:result_name_list '.'
        ('' |
         'would you like to learn more ?' | 'would you like to learn more about either of them ?' |
         'would you like to know more about them ?' | 'would you like to hear more about them ?' |
         'are you interested to hear more about any of them ?')
        => [name_list, null, null];

    ('i see' | 'i have' | 'i have found') name_list:result_name_list '.' ('they' | 'all of them') 'are' info:result_info_phrase '.'
        => D.checkListProposal(name_list, null, info);

    ('i see' | 'i have' | 'i have found') name_list:result_name_list '.' 'both are' info:result_info_phrase '.' => {
        if (name_list.length !== 2)
            return null;
        return D.checkListProposal(name_list, null, info);
    };

    ('i see' | 'i have' | 'i have found') name_list:result_name_list '.' action:action_coref_proposal => {
        const resultType = name_list[0].value.id.getType();
        if (!C.hasArgumentOfType(action, resultType))
            return null;

        return [name_list, null, action];
    };
}

negative_proposal_answer_preamble = {
    'i need';
    'i was thinking more of';
    'i would like';
    'i would like';
    'i am looking for';
    'do you have';
    'can you find';
    'is there';
    'that does not sound great , do you have';
}

specific_negative_proposal_preamble = {
    ( ('i am not in the mood for a' | 'i do not like' | 'i do not want') phrase:answer_noun_phrase
    | ('i am not in the mood for' | 'i do not like' | 'i do not want') phrase:anything_phrase
    ) => phrase;
}

generic_negative_proposal_reply = {
    'i do not like that';
    'i do not like that , do you have any other option ?';
}

system_generic_proposal = {
    ctx:ctx_search_command ('are you looking for a' | 'how about a' | 'how about the') proposal:answer_noun_phrase '?'
        => D.makeRefinementProposal(ctx, proposal);

    ctx:search_result_preamble ('are you looking for a' | 'how about a' | 'how about the') proposal:answer_noun_phrase '?'
        => D.makeRefinementProposal(ctx, proposal);
}

accept_phrase = {
    'i like that';
    'yes i like that';
    'sure i like that';
    'sounds good';
}

tell_me_more_phrase = {
    'can you tell me more ?';
    'can you tell me more about it ?';
    'can you give me more info ?';
    'give me more info !';
    'give me more information .';
    'tell me more .';
}

verbose_negative_list_proposal_reply_pair = {
    prop:system_list_proposal '<sep>' ('no ,' | 'no' | '') preamble:specific_negative_proposal_preamble => {
        const [results, info, action] = prop;
        if (info === null)
            return null;
        if (!D.isValidNegativePreambleForInfo(info, preamble))
            return null;
        return [results, preamble];
    };
}

negative_list_proposal_reply_pair = {
    ( prop:system_list_proposal '<sep>' ('no ,' | 'no' | '') negative_proposal_answer_preamble ('a' | 'any') request:answer_noun_phrase
    | prop:system_list_proposal '<sep>' ('no ,' | 'no' | '') negative_proposal_answer_preamble request:anything_phrase
    ) => {
        const [results, info, action] = prop;
        const proposalType = results[0].value.id.getType();
        const idType = request.schema.getArgType('id');

        if (!idType || !idType.equals(proposalType))
            return null;
        return [results, action, request];
    };

    pair:verbose_negative_list_proposal_reply_pair [weight=5] => {
        const [results, action, preamble] = pair;
        // convert the preamble into a request by negating it
        const clone = preamble.clone();
        clone.filter = new Ast.BooleanExpression.Not(null, clone.filter);
        return [results, action, clone];
    };

    ( pair:verbose_negative_list_proposal_reply_pair negative_proposal_answer_preamble ('a' | 'any') request:answer_noun_phrase
    | pair:verbose_negative_list_proposal_reply_pair negative_proposal_answer_preamble request:anything_phrase
    ) => D.mergePreambleAndRequest(pair, request);
}

positive_list_proposal_reply_pair = {
    ( prop:system_list_proposal '<sep>' ('ok' | 'yeah' | '') ('i like' | 'i am interested in' | 'i am intrigued by') name:constant_name '.' [weight=0.5]
    | prop:system_list_proposal '<sep>' ('ok' | 'yeah' | '') name:constant_name 'sounds' ('good' | 'really good' | 'nice' | 'interesting') '.' [weight=0.5]
    ) => {
        const [results, info, actionProposal] = prop;
        let good = false;
        for (let result of results) {
            if (result.value.id.equals(name)) {
                good = true;
                break;
            }
        }
        if (!good)
            return false;

        return [results, actionProposal, name, actionProposal];
    };

    prop:system_list_proposal '<sep>' ('ok' | 'yeah' | '') ('i will go' | 'i will take' | 'i am good for') name:constant_name '.' => {
        const [results, info, actionProposal] = prop;
        if (actionProposal === null)
            return null;
        let good = false;
        for (let result of results) {
            if (result.value.id.equals(name)) {
                good = true;
                break;
            }
        }
        if (!good)
            return false;

        return [results, actionProposal, name, actionProposal];
    };

    ( prop:system_list_proposal '<sep>' ('ok' | 'yeah' | '') 'can you tell me more about' name:constant_name '?' [weight=0.33]
    | prop:system_list_proposal '<sep>' ('ok' | 'yeah' | '') ('i like' | 'i am interested in' | 'i am intrigued by') name:constant_name '.' tell_me_more_phrase [weight=0.33]
    | prop:system_list_proposal '<sep>' ('ok' | 'yeah' | '') name:constant_name 'sounds' ('good' | 'really good' | 'nice' | 'interesting') '.' tell_me_more_phrase [weight=0.33]
    ) => {
        const [results, info, actionProposal] = prop;
        let good = false;
        for (let result of results) {
            if (result.value.id.equals(name)) {
                good = true;
                break;
            }
        }
        if (!good)
            return false;

        // set the action to null, which will hit the "tell me more" path
        return [results, actionProposal, name, null];
    };
}

verbose_negative_proposal_reply_pair = {
    prop:system_generic_proposal '<sep>' ('no ,' | 'no' | '') preamble:specific_negative_proposal_preamble => {
        if (!D.isValidNegativePreambleForInfo(prop, preamble))
            return null;
        return [prop, preamble];
    };
}

negative_proposal_reply_pair = {
    ( prop:system_generic_proposal '<sep>' ('no ,' | 'no' | '') negative_proposal_answer_preamble ('a' | 'any') request:answer_noun_phrase
    | prop:system_generic_proposal '<sep>' ('no ,' | 'no' | '') negative_proposal_answer_preamble request:anything_phrase
    | prop:system_generic_proposal '<sep>' ('no ,' | 'no' | '') request:generic_answer
    ) => {
        if (!C.isSameFunction(prop.schema, request.schema))
            return null;
        const refined = D.refineFilterToChangeFilter(prop.filter, request.filter);
        if (refined === null)
            return null;
        return [prop, request];
    };

    pair:verbose_negative_proposal_reply_pair [weight=5] => {
        const [prop, preamble] = pair;
        // convert the preamble into a request by negating it
        const clone = preamble.clone();
        clone.filter = new Ast.BooleanExpression.Not(null, clone.filter);
        return [prop, clone];
    };

    ( pair:verbose_negative_proposal_reply_pair negative_proposal_answer_preamble ('a' | 'any') request:answer_noun_phrase
    | pair:verbose_negative_proposal_reply_pair negative_proposal_answer_preamble request:anything_phrase
    ) => D.mergePreambleAndRequest(pair, request);
}

positive_proposal_reply_pair = {
    prop:system_generic_proposal '<sep>' accept_phrase => [prop, prop];
}

verbose_negative_recommendation_reply_pair = {
    prop:system_direct_proposal '<sep>' ('no ,' | 'no' | '') preamble:specific_negative_proposal_preamble => {
        const [topResult, action] = prop;
        if (D.isFilterCompatibleWithResult(topResult, preamble.filter))
            return null;
        return [topResult, action, preamble];
    };
}

negative_recommendation_reply_pair = {
    ( prop:system_direct_proposal '<sep>' ('no ,' | 'no' | '') negative_proposal_answer_preamble ('a' | 'any') request:answer_noun_phrase
    | prop:system_direct_proposal '<sep>' ('no ,' | 'no' | '') negative_proposal_answer_preamble request:anything_phrase
    ) => {
        const [topResult, action] = prop;
        const proposalType = topResult.value.id.getType();
        const idType = request.schema.getArgType('id');

        if (!idType || !idType.equals(proposalType))
            return null;
        return [topResult, action, request];
    };

    pair:verbose_negative_recommendation_reply_pair [weight=5] => {
        const [topResult, action, preamble] = pair;
        // convert the preamble into a request by negating it
        const clone = preamble.clone();
        clone.filter = new Ast.BooleanExpression.Not(null, clone.filter);
        return [topResult, action, clone];
    };
}

positive_recommendation_reply_pair = {
    prop:system_direct_proposal '<sep>' accept_phrase [repeat=true] => {
        const [topResult, actionProposal] = prop;
        // if the user did not give an action earlier, and no action
        // was proposed by the agent right now, the flow is roughly
        //
        // U: hello i am looking for a restaurant
        // A: how about the ... ?
        // U: sure I like that
        //
        // this doesn't make much sense, so we don't want this flow
        if (actionProposal === null)
            return null;

        return [topResult, actionProposal, actionProposal];
    };

    ( prop:system_direct_proposal '<sep>' tell_me_more_phrase [weight=0.5]
    | prop:system_direct_proposal '<sep>' accept_phrase tell_me_more_phrase [weight=0.5]
    ) => {
        const [topResult, actionProposal] = prop;
        // set the action to null, which will hit the "tell me more" path
        return [topResult, actionProposal, null];
    };
}

initial_command = {
    action_command [weight=3];
    search_command;
    complete_question [weight=0.1];
    projection_question [weight=0.1];

    prog:initial_program => {
        if (prog.rules.length !== 1)
            return null;
        return prog.rules[0];
    };
}

$root = {
    ctx:ctx_init greeting [weight=0.01] =>
        D.checkStateIsValid(ctx, null, new Ast.DialogueState(null, D.POLICY_NAME, 'greet', null, []));

    ( ctx:ctx_init stmt:initial_command [weight=0.5]
    | ctx:ctx_init greeting stmt:initial_command [weight=0.5]
    ) => {
        const userState = D.initialRequest(stmt);
        if (userState === null)
            return null;
        return D.checkStateIsValid(ctx, null, userState);
    };

    ctx:ctx_greet ('hello' | 'hi') ('!' | ',') ('how can i help you' | 'what are you interested in' | 'what can i do for you') '?' '<sep>' stmt:initial_command => {
        const userState = D.initialRequest(stmt);
        if (userState === null)
            return null;
        const sysState = D.makeSimpleState(ctx, 'sys_greet', null);
        return D.checkStateIsValid(ctx, sysState, userState);
    };

    // query refinement (through proposal or slot fill)
    ctx:ctx_search_command qa:precise_search_question_answer_pair [weight=5] =>
        D.preciseSearchQuestionAnswer(ctx, qa);

    ctx:ctx_search_command qa:imprecise_search_question_answer_pair [weight=5] =>
        D.impreciseSearchQuestionAnswer(ctx, qa);

    ( ctx:ctx_search_command pair:negative_proposal_reply_pair [weight=0.5]
    | ctx:ctx_search_command pair:positive_proposal_reply_pair [weight=0.5]
    ) =>
        D.proposalReplyPair(ctx, pair);

    // action recommendation (through one or a list)
    ctx:ctx_complete_search_command pair:negative_recommendation_reply_pair [weight=0.3]
        => D.negativeRecommendationReplyPair(ctx, pair);
    ctx:ctx_complete_search_command pair:positive_recommendation_reply_pair [weight=0.7]
        => D.positiveRecommendationReplyPair(ctx, pair);

    ctx:ctx_complete_search_command pair:negative_list_proposal_reply_pair [weight=0.3]
        => D.negativeListProposalReplyPair(ctx, pair);
    ctx:ctx_complete_search_command pair:positive_list_proposal_reply_pair [weight=0.7]
        => D.positiveListProposalReplyPair(ctx, pair);
}
